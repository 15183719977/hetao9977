# 继承与多态

- 面向对象的**三大特征**：封装性、继承性、多态性。

## 继承

- **继承是多态的前提**，如果没有继承，就没有多态。
- 继承主要解决的问题就是：共性抽取。
- 继承关系当中的特点：
  1. 子类可以拥有父类的“内容”；
  2. 子类还可以拥有自己专有的内容。

- **继承的格式**：

  - 定义父类的格式：（一个普通的类定义）

  ```
  public class 父类名称{
  	//……
  }
  ```

  - 定义一个子类的格式：

  ```
  public class 子类名称 extends 父类名称{
  	//……
  }
  ```

- 在父子类的继承关系中，如果**成员变量重名**，则创建子类对象时，访问有两种方式：
  1.  直接通过子类对象访问成员变量：等号左边是谁，就优先用谁，没有则向上找。
  2. 间接通过成员方法访问成员变量：方法属于谁，就优先使用谁，没有则向上找。

- 子类的局部变量、成员变量、父类的成员变量同名时，访问方法：
  - 局部变量：直接写成员变量名，优先原则，使用局部变量。
  - 本类的成员变量：`this.成员变量名`。
  - 父类的成员变量：`super.成员变量名`。

- 在父子类的继承关系中，创建子类对象，访问成员方法的规则：
  
- 创建的对象是谁，就优先使用谁，如果没有则向上找。
  
- **重写（Override）**：方法的名称一样，参数列表也一样。

  - 特点：创建的是子类对象，则优先用子类方法。 

  - 【注意事项1】必须保证父子类之间方法的名称相同，参数列表也相同。

    `@Override`:写在方法的前面，用来检测是不是有效的正确覆盖重写。

  - 【注意事项2】子类方法的返回值必须小于等于父类方法的返回值范围。

    **`Object`类是所有类的公共最高父类**，`String`类是`Object`类的子类。

  - 【注意事项3】子类方法的权限必须大于等于父类方法的权限修饰符。

    `public>protected>(default)>private`

    `(default)`不是关键字`default`，而是表示什么都不写，留空。

- **继承中构造方法的访问特点**：
  1. 子类构造方法当中有一个默认隐含的`super()`调用，所以一定是先调用父类构造，后执行子类构造。
  2. 子类构造可以通过`super()`来调用父类重载构造。
  3. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造语句调用多次super构造。

- **`super`关键字**的3种用法：
  1. 在子类的成员方法中，访问父类的成员变量。
  2. 在子类的成员方法中，访问父类的成员方法。
  3. 在子类的构造方法中，访问父类的构造方法。

- **`this`关键字**的3种用法：

  1. 在本类的成员方法中，访问本类的成员变量。
  2. 在本类的成员方法中，访问本类的另一个成员方法。
  3. 在本类的构造方法中，访问本类的另一个构造方法。

  【注意】：`this(…)`调用也必须是构造方法的第一个语句，唯一一个。

  ​					`super`和`this`两种构造调用，不能同时使用。

- **Java继承的特点**：
  1. Java语言是**单继承**的。一个类的直接父类只能有唯一一个。
  2. Java语言可以**多级继承**。
  3. 一个子类的直接父亲是唯一的，但是一个父类可以拥有很多个子类。

## 抽象类

- 抽象方法：就是加上`abstract`关键字，然后去掉大括号{}，直接分号结束。

- 抽象类：抽象方法所在的类，必须是抽象类。在`class`之前写上`abstract`即可。

- 如何使用抽象类和抽象方法？

  - 不能直接创建`new`抽象类对象。

  - 必须用一个子类来继承抽象父类。

  - 子类要覆盖重写抽象父类当中所有的抽象方法。

    覆盖重写（实现）：子类去掉抽象方法的`abstract`关键字，然后补上方法体大括号。

  - 创建子类对象进行使用。

- 【注意事项】
  1. 抽象类不能创建对象，只能创建其非抽象子类的对象。
  2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。
  3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
  4. 抽象类的子类，必须重写父类中的所有抽象方法，不然子类仍然是抽象类。



## 接口

- 接口就是多个类的**公共规范**。

- 接口就是一种引用数据类型，最重要的内容就是其中的：抽象方法。

- **接口的格式**：

  ```
  public interface 接口名称{
  	//……
  } 
  ```

- 接口中可以包含的内容：
  - Java 7：常量、抽象方法
  - Java 8：常量、抽象方法、默认方法、静态方法
  - **Java 9：常量、抽象方法、默认方法、静态方法、私有方法**

- 任何版本的Java中，接口都能定义抽象方法。

  - 格式：

    `public abstract 返回值类型 方法名称(参数列表)；`

  - 【注意事项】
    1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：`public abstract` 。
    2. 这两个关键字修饰符，可以选择性的省略。
    3. 方法的三要素，可以随意定义。

- **接口使用步骤**：

  1. 接口不能直接使用，必须有一个“实现类”来“实现”该接口。

     格式：

     ```
     public class 实现类名称 implements 接口名称{
     	//……
     }
     ```

  2. 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。

     实现：去掉`abstract`关键字，加上方法体大括号。

  3. 创建实现类的对象，进行使用。

- 从Java 8开始，接口里允许定义**默认方法**。

  - 格式：

    ```
    public default 返回值类型 方法名称(参数列表){
    	方法体
    }
    ```

  - 接口当中的默认方法，可以解决接口升级的问题。
  - 接口的默认方法，可以通过接口实现类对象，直接调用。
  - 接口的默认方法，也可以被接口实现类进行覆盖重写。

- 从Java 8开始，接口里允许定义**静态方法**。

  - 格式：

    ```
    public static 返回值类型 方法名称(参数列表){
    	方法体
    }
    ```

  - 【注意】不能通过接口实现类的对象来调用接口当中的静态方法。

    正确方法：通过接口名称，直接调用其中的静态方法。

    格式：`接口名称.静态方法名(参数)；`

- 从Java 9开始，接口里允许定义**私有方法**。

  1. 普通私有方法，解决多个默认方法之间重复代码的问题。

     格式：

     ```
     private 返回值类型 方法名称(参数列表){
     	方法体
     }
     ```

  2. 静态私有方法，解决多个静态方法之间重复代码的问题。

     格式：

     ```
     private static 返回值类型 方法名称(参数列表){
     	方法体
     }
     ```

- 接口的常量定义与使用

  - 格式：

    `public static final 数据类型 常量名称 = 数据值；`

    一旦使用`final`关键字进行修饰，说明不可改变。

  - 【注意事项】
    1. 接口当中的常量，可以省略`public static final`，但是，省略也是一样的意思。
    2. 接口当中的常量，必须进行赋值。
    3. 接口当中常量的名称，使用完全大写的字母，用下划线进行分割。(推荐命名规则)

- 使用接口的【**注意事项**】

  1. 接口是没有静态代码块或者构造方法的。

  2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。

     格式：

     ```
     public class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB{
     	//覆盖重写所有抽象方法
     }
     ```

  3. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。

  4. 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么该实现类就必须是抽象类。

  5. 如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。

  6. 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先使用父类当中的方法。

- 接口之间的多继承
  1. 类和类之间是单继承，直接父类只有一个。
  2. 类与接口之间是多实现的，一个类可以实现多个接口。
  3. 接口和接口之间是多继承的。
  4. 【注意事项】
     - 多个父接口当中的抽象方法如果重复，没关系。（因为没有方法体）
     - 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，并且**带着`default`关键字**。

## 多态

- `extends`继承或者`implements`实现，是多态性的前提。

- 代码当中体现多态性：父类引用指向子类对象。

  格式：

  `父类名称 对象名 = new 子类名称();`

  或者：

  `接口名称 对象名 = new 实现类名称();`

- **多态中成员变量**的使用特点
  1. 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。
  2. 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。

- **多态中成员方法**的访问规则：
  
  - 看new的是谁，就优先用谁，没有则向上找。
- **口诀：编译看左边，运行看右边。**
  
- 对象的向上转型，就是多态写法。
  - 格式：`父类名称 对象名 = new 子类名称()；`
  - 含义：右侧创建一个子类对象，把它当作父类来看待使用。
  - 【注意事项】：向上转型一定是安全的。

- 对象的向下转型，其实是一个**还原**的动作。

  - 格式：`子类名称 对象名 = (子类名称)父类的对象；`
  - 含义：将父类对象，还原成为本类的子类对象。

  - 【注意事项】：对象创建时，本来就是子类，才能够向下转型为子类；否则会报错`ClassCastException`。

- `instanceof`关键字

  格式：

  `对象 instanceof 类名称`	

  返回一个boolean值结果，判断前面的对象能不能当做后边类型的实例，即判断能不能进行向下转型。

## final关键字

- `final`关键字代表最终、不可改变。
- `final`常见四中用法：
  1. 可以用来修饰一个类。
  2. 可以用来修饰一个方法。
  3. 可以用来修饰一个局部变量。可以用来修饰一个成员变量。

- `final`关键字用于修饰类。

  格式：

  ```
  public final class 类名称{
  	//……
  }
  ```

  含义：当前这个类不能有任何的子类。

  注意：一个类如果是`final`的，那么其中所有的成员方法都无法进行覆盖重写。

- `final`关键字用于修饰成员方法。

  格式：

  ```
  修饰符 final 返回值类型 方法名称(参数列表){
  	//……
  }
  ```

  【注意事项】：对于类、方法来说，`abstract`关键字和`final`关键字不能同时使用，因为矛盾。

- `final`关键字用于修饰局部变量。
  1. 对于基本类型来说，不可变指的是变量当中的数据不可变。
  2. 对于引用类型来说，不可变指的是变量当中的地址值不可变，该地址中存放的数据是可以改变的。

- `final`关键字用于修饰成员变量。
  1. 由于成员变量具有默认值，所以用了`final`之后必须手动给成员变量赋值，不会再给默认值。
  2. 对于`final`的成员变量，要么使用直接赋值，要么通过构造方法赋值，二者选其一。
  3. 必须保证类当中所有重载的构造方法，都最终会对`final`的成员变量进行赋值。

## 四种权限修饰符

|                | `public` | `protected` | `（default）` | `private` |
| -------------- | -------- | ----------- | ------------- | --------- |
| 同一个类       | YES      | YES         | YES           | YES       |
| 同一个包       | YES      | YES         | YES           | NO        |
| 不同包、子类   | YES      | YES         | NO            | NO        |
| 不同包、非子类 | YES      | NO          | NO            | NO        |

注：`(default)`并不是关键字`"default"`，而是根本不写。