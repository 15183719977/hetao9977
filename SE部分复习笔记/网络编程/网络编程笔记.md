**网络编程：**

计算机网络实现了不同计算机之间的通信，这必须依靠编写网络通讯程序来实现。Java已经将网络程序所需要的东西封装成不同的类。只要创建这些类的对象，使用相应的方法。

**计算机网络：**计算机网络是指将地理位置不同的具有独立功能的（而不是脱离网络就无法存在的）多台计算机(大中小型服务器，台式机、笔记本等)及其外部设备(路由器、交换机等)，通过通信线路(双绞线、光纤等)连接起来，在网络操作系统(Windows
2000 Server/Advance
Server、Unix、Linux等)，网络管理软件(WorkWin、SugarNMS等)及网络通信协议(如TCP/IP协议栈等)的管理和协调下，实现（作用）资源共享和信息传递的计算机系统。

**网络通信协议：**国际标准化组织(ISO，即International Organization for
Standardization)定义了网络通信协议的基本框架，被称为OSI(Open System
Interconnect，即开放系统互联)模型。OSI模型将这些通讯标准进行层次划分，每一层次解决一个类别的问题，这样就使得标准的制定没那么复杂。OSI模型制定的七层标准模型：

![IMG_256](media/b6b9de7e5473bae565ff998eb1a1c6cc.png)

OSI网络通信协议模型，是一个参考模型，而TCP（Transmission Control
Protocol传输控制协议）/IP（Internet Protocol网络协议）协议是事实上的标准

TCP/IP中有两个重要的协议，传输层的TCP协议和互连网络层的IP协议，因此就拿这两个协议做代表，来命名整个协议族了，再说TCP/IP协议时，是指整个协议族。

![IMG_256](media/09bf5520af8ce69b0f186bc8c485211b.png)

网络层：互联网络层；物理+数据链路层：网络接口层

** IP地址： **用来标识网络中的一个通信实体的地址。通信实体可以是计算机、路由器（连接两个或多个网络的网络设备）等

 IPV4：32位地址，并以8位为一个单位，分成四部分，以点分十进制表示，因为8位二进制的计数范围是00000000---11111111，对应十进制的0-255。

IPV6：128位(16个字节)写成8个16位的无符号整数，每个整数用四个十六进制位表示，每个数之间用冒号(：)分开，如：3ffe:3201:1401:1280:c8ff:fe4d:db39:1984

**端口：**一台计算机只有单一的连到网络的物理连接（Physical
Connection），所有的数据都通过此连接对内、对外送达特定的计算机，这就是（物理）端口（port）。一台计算机上可能提供多种网络应用程序，如何来区分这些不同的程序呢?这就要用到（虚拟）端口。端口是虚拟的概念，并不是说在主机上真的有若干个端口。通过端口，可以在一个主机上运行多个网络应用程序

**总结：**

 1.
IP地址好比每个人的地址(门牌号)，端口好比是房间号。必须同时指定IP地址和端口号才能够正确的发送数据。

 2. IP地址好比为电话号码，而端口号就好比为分机号。

**Socket，套接字：Java将套接字抽象化为类**

   
  我们开发的网络应用程序位于应用层，TCP和UDP属于传输层协议，在应用层如何使用传输层的服务呢?在应用层和传输层之间，则是使用套接Socket来进行分离。

   
  套接字就像是传输层为应用层开的一个小口，应用程序通过这个小口向远程发送数据，或者接收远程发来的数据;而这个小口以内，也就是数据进入这个口之后，或者数据从这个口出来之前，是不知道也不需要知道的，也不会关心它如何传输，这属于网络其它层次工作。

   
  Socket实际是传输层供给应用层的编程接口。Socket就是应用层与传输层之间的桥梁。使用Socket编程可以开发客户机和服务器应用程序，可以在本地网络上进行通信，也可通过Internet在全球范围内通信。

![IMG_256](media/90e169090a77696fb44cb4eed7e8db50.png)

**请求-响应”模式：**

      1. Socket类：发送TCP消息。

      2. ServerSocket类：创建服务器。

   
  套接字是一种进程间的数据交换机制。这些进程既可以在同一机器上，也可以在通过网络连接的不同机器上。换句话说，套接字起到通信端点的作用。单个套接字是一个端点，而一对套接字则构成一个双向通信信道，使非关联进程可以在本地或通过网络进行数据交换。一旦建立套接字连接，数据即可在相同或不同的系统中双向或单向发送，直到其中一个端点关闭连接。套接字与主机地址和端口地址相关联。主机地址就是客户端或服务器程序所在的主机的IP地址。端口地址是指客户端或服务器程序使用的主机的通信端口。

   
  在客户端和服务器中，分别创建独立的Socket，并通过Socket的属性，将两个Socket进行连接，这样，客户端和服务器通过套接字所建立的连接使用输入输出流进行通信。

      TCP/IP套接字是最可靠的双向流协议，使用TCP/IP可以发送任意数量的数据。

   
  实际上，套接字只是计算机上已编号的端口。如果发送方和接收方计算机确定好端口，他们就可以通信了。

![IMG_256](media/f3a4a756912ef03f7a36288340863bb7.png)

**网络协议的分层**：由于网络结点之间联系很复杂，在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层（上一层给下一层提供服务），而与再下一层不发生关系。（下一层给上一层供应编程接口）

 
 把用户应用程序作为最高层，把物理通信线路作为最低层，将其间的协议处理分为若干层，规定每层处理的任务，也规定每层的接口标准。

**数据封装与解封：**

     
由于用户传输的数据一般都比较大，有的可以达到MB字节，一次性发送出去十分困难，于是就需要把数据分成许多片段，再按照一定的次序发送出去。这个过程就需要对数据进行封装。

      数据封装(Data
Encapsulation)是指将协议数据单元(PDU)封装在一组协议头和协议尾中的过程。在OSI七层参考模型中，每层主要负责与其它机器上的对等层进行通信。该过程是在协议数据单元(PDU)中实现的，其中每层的PDU一般由本层的协议头、协议尾和数据封装构成。

 1.数据发送处理过程

   
    (1)应用层将数据交给传输层，传输层添加上TCP的控制信息(称为TCP头部)，这个数据单元称为段(Segment)，加入控制信息的过程称为封装。然后，将段交给网络层。

     
  (2)网络层接收到段，再添加上IP头部，这个数据单元称为包(Packet)。然后，将包交给数据链路层。

        (3)
数据链路层接收到包，再添加上MAC头部和尾部，这个数据单元称为帧(Frame)。然后，将帧交给物理层。

        (4)物理层将接收到的数据转化为比特流，然后在网线中传送。

![IMG_256](media/a28e1a4c44885e92198051e8b7b85bf9.png)

  2.数据接收处理过程

        (1)物理层接收到比特流，经过处理后将数据交给数据链路层。

     
  (2)数据链路层将接收到的数据转化为数据帧，再除去MAC头部和尾部，这个除去控制信息的过程称为解封，然后将包交给网络层。

        (3)网络层接收到包，再除去IP头部，然后将段交给传输层。

        (4)传输层接收到段，再除去TCP头部，然后将数据交给应用层。

![IMG_256](media/3c239d3845dd1562d7f3a3ce5c8d9080.png)

      从以上传输过程中，可以总结出以下规则：

        (1)发送方数据处理的方式是从高层到底层，逐层进行数据封装。

        (2)接收方数据处理的方式是从底层到高层，逐层进行数据解封装。

   
  接收方的每一层只把对该层有意义的数据拿走，或者说每一层只能处理发送方同等层的数据，然后把其余的部分传递给上一层，这就是对等层通信的概念。

 
**Java为了可移植性，不允许直接调用操作系统，而是由java.net包来提供网络功能。Java虚拟机负责提供与操作系统的实际连接。下面我们来介绍几个java.net包中的常用的类。**

1.  InetAddress：封装了IP和DNS（Domain Name System，域名系统），没有端口信息。

**import** java.net.InetAddress;

**import** java.net.UnknownHostException;//主机不存在或网络连接错误

方法：这个类没有构造方法。如果要得到对象，只能通过静态方法：getLocalHost()、getByName()、
getAllByName()、 getAddress()、getHostName()。

**public** **class** Test1 {

    **public** **static** **void** main(String[] args) **throws** UnknownHostException {

        InetAddress addr = InetAddress.getLocalHost();//使用getLocalHost方法创建InetAddress对象//返回本地主机的InetAddress对象

        //返回IP地址：192.168.1.110

        System.out.println(addr.getHostAddress()); //获取InetAddress对象所包含的IP地址

        //输出计算机名：gaoqi

        System.out.println(addr.getHostName());    //获取此IP地址的主机名

    }

}

**public** **class** Test2 {

    **public** **static** **void** main(String[] args) **throws** UnknownHostException {

        InetAddress addr = InetAddress.getByName("www.sxt.cn");//根据域名得到InetAddress对象//getByName（String
host）//获取与host相对应的InetAddress对象

        // 返回 sxt服务器的IP:59.110.14.7

        System.out.println(addr.getHostAddress());

        // 输出：www.sxt.cn

        System.out.println(addr.getHostName());

    }

}

**public** **class** Test3 {

    **public** **static** **void** main(String[] args) **throws** UnknownHostException {

        InetAddress addr = InetAddress.getByName("59.110.14.7");//根据IP得到InetAddress对象

        // 返回sxt服务器的IP：59.110.14.7

        System.out.println(addr.getHostAddress());

        /\*

         \* 输出ip而不是域名。如果这个IP地址不存在或DNS服务器不允许进行IP地址

         \* 和域名的映射，getHostName方法就直接返回这个IP地址。

         \*/

        System.out.println(addr.getHostName());

    }

}

1.  InetSocketAddress：封装了IP和端口

包含IP和端口信息，常用于Socket通信。此类实现 IP 套接字地址(IP 地址 +
端口号)，不依赖任何协议。

**import** java.net.InetSocketAddress;

**public** **class** Test4 {

    **public** **static** **void** main(String[] args) {

        InetSocketAddress socketAddress = **new** InetSocketAddress("127.0.0.1", 8080);

        InetSocketAddress socketAddress2 = **new** InetSocketAddress("localhost", 9000);

        System.out.println(socketAddress.getHostName());

        System.out.println(socketAddress2.getAddress());///getAddress()获取发送或接收方计算机的IP地址，此数据报将要发往该机器或者是从该机器接收到的。

    }

}

1.  URL(Uniform Resource Locator)，统一资源定位符：代表一个网络的资源

      IP地址唯一标识了Internet上的计算机，而URL则标识了这些计算机上的资源。类
URL
代表一个统一资源定位符，它是指向互联网“资源”的指针。资源可以是简单的文件或目录，也可以是对更为复杂的对象的引用，例如对数据库或搜索引擎的查询。为了方便程序员编程，JDK中提供了URL类，该类的全名是java.net.URL，有了这样一个类，就可以使用它的各种方法来对URL对象进行分割、合并等处理。

1.  方法：

**import** java.net.MalformedURLException;

**import** java.net.URL;

**public** **class** Test5 {

    **public** **static** **void** main(String[] args) **throws** MalformedURLException {

        URL u = **new** URL("http://www.google.cn:80/webhp\#aa?canhu=33");//URL由4部分组成：协议
、存放资源的主机域名、资源文件名和端口号。如果未指定该端口号，则使用协议默认的端口。例如http
协议的默认端口为 80。 在浏览器中访问网页时，地址栏显示的地址就是URL。

        System.out.println("获取与此url关联的协议的默认端口：" + u.getDefaultPort());//80

        System.out.println("getFile:" + u.getFile()); // 端口号后面的内容///webhp

        System.out.println("主机名：" + u.getHost()); // www.google.cn//主机域名

        System.out.println("路径：" + u.getPath()); // 端口号后，参数前的内容///webhp

        // 如果www.google.cn:80则返回80.否则返回-1

        System.out.println("端口：" + u.getPort()); 

        System.out.println("协议：" + u.getProtocol());//http

        System.out.println("参数部分：" + u.getQuery());//null

        System.out.println("锚点：" + u.getRef());//aa?canhu=33

 

        URL u1 = **new** URL("http://www.abc.com/aa/");

        URL u2 = **new** URL(u, "2.html"); // 相对路径构建url对象

        System.out.println(u2.toString()); // http://www.abc.com/aa/2.html

    }

}

1.  openStream 跟流联系了起来（网络爬虫）

**import** java.io.BufferedReader;

**import** java.io.InputStream;

**import** java.io.InputStreamReader;

**import** java.net.MalformedURLException;

**import** java.net.URL;

**public class** SpiderTest01 {

**public static void** main(String[] args) **throws** Exception {

// **TODO** 自动生成的方法存根

URL url=**new** URL("https://www.jd.com");

InputStream is=url.openStream();//打开流

BufferedReader br=**new** BufferedReader(**new** InputStreamReader(is,"UTF-8"));

/\*URL url=**new** URL("https://www.dianping.com");//返回403拒绝掉

HttpURLConnection conn=(HttpURLConnection)url.openConnection();//打开连接

conn.setRequestMethod("GET");//设置请求方式

conn.setRequestProperty("User-Agent","Mozilla/5.0 (Windows NT 10.0; WOW64)
AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132
Safari/537.36");//设置请求协议

BufferedReader br=**new** BufferedReader(**new**
InputStreamReader(conn.getInputStream(),"UTF-8"));\*////模拟浏览器的GET请求

String msg=**null**;

**while**(**null**!=(msg=br.readLine())) {

System.*out*.println(msg);

}

br.close();

}

}

html：超文本标记语言 骨架

CSS:层叠样式表 美化

js:JavaScript动态语言 边解释边执行 能动了 Java反射让其动（动态特性）了起来

 TCP协议和UDP协议是传输层的两种协议。Socket是传输层供给应用层的编程接口，所以Socket编程就分为TCP编程和UDP编程两类。

客户端：第一次主动发起通讯的程序被称作客户端(Client)程序。

服务器：第一次通讯中等待连接的程序被称作服务器端(Server)程序。

一旦通讯建立，则客户端和服务器端完全一样，没有本质的区别。

**TCP/IP通信连接的简单过程：**位于A计算机上的TCP/IP软件向B计算机发送包含端口号的消息，B计算机的TCP/IP软件接收该消息，并进行检查，查看是否有它知道的程序正在该端口上接收消息。如果有，他就将该消息交给这个程序。

1.  TCP通讯（Transmission Control Protocol传输控制协议）

    1.  特点：面向连接的（以固定连线为基础的协议），传输数据安全，稳定，效率相对较低（在认证上存在额外耗费）。

 TCP是面向连接的，所谓面向连接，就是当计算机双方通信时必需经过先建立连接，然后传送数据，最后拆除连接三个过程。

**TCP在建立连接时又分三步走：**

   
  第一步，是请求端(客户端)发送一个包含SYN(Synchronize)即同步标志的TCP报文，SYN同步报文会指明客户端使用的端口以及TCP连接的初始序号。

   
  第二步，服务器在收到客户端的SYN报文后，将返回一个SYN+ACK(Acknowledgement)即同步标志+确认的报文，表示客户端的请求被接受，同时TCP序号被加一。

   
  第三步，客户端也返回一个ACK确认报文给服务器端，同样TCP序列号被加一，到此一个TCP连接完成。然后才开始通信的第二步：数据处理。

      这就是所说的TCP的三次握手(Three-way Handshake)。

>   **单向通信：**

1.  ServerSocket

>   /\*\*

\* 熟悉流程

\* 创建服务器

\* 1、指定端口 使用ServerSocket创建服务器

\* 2、阻塞式等待连接 accept

\* 3、操作: 输入输出流操作

\* 4、释放资源

\*/

**public class** Server {

**public static void** main(String[] args) **throws** Exception {

System.*out*.println("-----Server-----");

// 1、指定端口 使用ServerSocket创建服务器 // 建立服务器端套接字：指定监听的接口

ServerSocket server =**new** ServerSocket(8888);

// 2、阻塞式等待连接
accept//调用ServerSocket类的accept()方法会返回一个和客服端Socket对象相连接的Socket对象

Socket client =server.accept(); // 监听，等待客户端请求，并愿意接收连接

System.*out*.println("一个客户端建立了连接");//1.没有客户呼叫服务器，那么此语句不执行2.如果没有客户请求也没有阻塞
，则有其他程序占用端口号

// 3、操作: 输入输出流操作

DataInputStream dis =**new** DataInputStream(client.getInputStream());

String data =dis.readUTF();

System.*out*.println(data);

// 4、释放资源

dis.close();

client.close();

server.close();

}

>   }

1.  Socket

创建客户端

\* 1、建立连接: 使用Socket创建客户端 +服务的地址和端口

\* 2、操作: 输入输出流操作

\* 3、释放资源

\*/

**public class** Client {

**public static void** main(String[] args) **throws** UnknownHostException,
IOException {

System.*out*.println("-----Client-----");

//1、建立连接: 使用Socket创建客户端 +服务的地址和端口

/\*

             \* 创建Scoket对象：指定要连接的服务器的IP和端口而不是自己机器的

             \* 端口。发送端口是随机的。

             \*/

Socket client =**new** Socket("localhost",8888);//InetAddress.getLocalHost()

//2、操作: 输入输出流操作

DataOutputStream dos =**new** DataOutputStream(client.getOutputStream());

String data ="hello";

dos.writeUTF(data);

dos.flush();

//3、释放资源

dos.close();

client.close();

}

}

d):  1.
创建服务器ServerSocket，在创建时，定义ServerSocket的监听端口(在这个端口接收客户端发来的消息)。

      2. ServerSocket调用accept()方法，使之处于阻塞状态。等待了

      3. 创建客户端Socket，并设置服务器的IP及端口。

      4. 客户端发出连接请求，建立连接。

      5. 分别取得服务器和客户端Socket的InputStream和OutputStream。

      6. 利用Socket和ServerSocket进行数据传输。

      7. 关闭流及Socket。

e）：双向通信

**public class** MultiChat {

**public static void** main(String[] args) **throws** IOException {

System.*out*.println("-----Server-----");

// 1、指定端口 使用ServerSocket创建服务器

ServerSocket *server* =**new** ServerSocket(8888);

// 2、阻塞式等待连接 accept

**while**(**true**) {//其他客户必须等待之前的客户退出，才能继续 排队

Socket client =server.accept();

System.*out*.println("一个客户端建立了连接");

DataInputStream dis =**new** DataInputStream(client.getInputStream());

DataOutputStream dos =**new** DataOutputStream(client.getOutputStream());

**boolean** isRunning = **true**;

**while**(isRunning) {//实现一个客户可以正常收发多条消息

//3、接收消息

String msg =dis.readUTF();

//4、返回消息

dos.writeUTF(msg);

//释放资源

dos.flush();

}

dos.close();

dis.close();

client.close();

}

}

}

**public class** MultiClient {

**public static void** main(String[] args) **throws** UnknownHostException,
IOException {

System.*out*.println("-----Client-----");

//1、建立连接: 使用Socket创建客户端 +服务的地址和端口

Socket client =**new** Socket("localhost",8888);

//2、客户端发送消息

BufferedReader console =**new** BufferedReader(**new**
InputStreamReader(System.*in*));

DataOutputStream dos =**new** DataOutputStream(client.getOutputStream());

DataInputStream dis =**new** DataInputStream(client.getInputStream());

**boolean** isRunning = **true**;

**while**(isRunning) {

String msg = console.readLine();

dos.writeUTF(msg);

dos.flush();

//3、获取消息

msg =dis.readUTF();

System.*out*.println(msg);

}

dos.close();

dis.close();

client.close();

}

}

f)**多线程:客服端同上**

**public class** TMultiChat {

**public static void** main(String[] args) **throws** IOException {

System.*out*.println("-----Server-----");

// 1、指定端口 使用ServerSocket创建服务器

ServerSocket *server* =**new** ServerSocket(8888);

// 2、阻塞式等待连接 accept

**while**(**true**) {

Socket client =server.accept();

System.*out*.println("一个客户端建立了连接");

**new** Thread(()-\>{//Lambda表达式 **new** Thread(new Runnable(){public void
run() {}}

DataInputStream dis=**null**;

DataOutputStream dos=**null**;

**try** {

dis = **new** DataInputStream(client.getInputStream());

dos =**new** DataOutputStream(client.getOutputStream());

} **catch** (IOException e1) {

e1.printStackTrace();

}

**boolean** isRunning = **true**;

**while**(isRunning) {

//3、接收消息

String msg;

**try** {

msg = dis.readUTF();

//4、返回消息

dos.writeUTF(msg);

//释放资源

dos.flush();

} **catch** (IOException e) {

//e.printStackTrace();

isRunning = **false**; //停止线程

}

}

**try** {

**if**(**null**==dos) {

*dos*.close();

}

} **catch** (IOException e) {

e.printStackTrace();

}

**try** {

**if**(**null**==dis) {

*dis*.close();

}

} **catch** (IOException e) {

e.printStackTrace();

}

**try** {

**if**(**null**==client) *{*

*client.close();*

*}*

} **catch** (IOException e) {

e.printStackTrace();

}

}).start();

}

}

}

1.  UDP通信（User Datagram protocol 用户数据包协议）

    1.  特点：面向无连接的（无连接通信协议），传输数据不安全，效率较高。

    2.  DatagramPacket：数据打包

DatagramPacket(byte[] buf, int length) ：构造数据报包，用来接收长度为 length
的数据包。

    DatagramPacket(byte[] buf, int length, InetAddress address, int port)
：构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号。

  getAddress()
：获取发送或接收方计算机的IP地址，此数据报将要发往该机器或者是从该机器接收到的。

     getData() ：获取发送或接收的数据。

    setData(byte[] buf) ：设置发送的数据。

1.  DategramSocket：数据发送和接收

   DatagramSocket()
：构造数据报套接字并将其绑定到本地主机上任何可用的端口。(发送数据包)，send(DatagramPacket
p) ：从此套接字发送数据报包。

      DatagramSocket(int port)
：创建数据报套接字并将其绑定到本地主机上的指定端口。(接收数据包)，receive(DatagramPacket
p) ：从此套接字接收数据报包。

**import** java.net.DatagramPacket;

**import** java.net.DatagramSocket;

**import** java.net.InetSocketAddress;

**public class** UdpClient{

**public static void** main(String[] args) **throws** Exception {

System.*out*.println("发送方启动中...");

//客户端端口//7777//可空

DatagramSocket client = **new** DatagramSocket(7777);

//服务器端端口 //9999

String data="上海尚学堂";

**byte**[] datas = data.getBytes();

DatagramPacket packet = **new** DatagramPacket(datas,0,datas.length,**new**
InetSocketAddress("localhost",9999));

//发送数据报包

client.send(packet);

//关闭资源

client.close();//close() ：关闭此数据报套接字。

}

}

**public class** UdpServer {

**public static void** main(String[] args) **throws** Exception {

System.*out*.println("接收方启动中...");

//服务器端端口

DatagramSocket server = **new** DatagramSocket(9999);

//容器

**byte**[] container = **new byte**[1024\*60];//60kb

DatagramPacket packet = **new** DatagramPacket(container, container.length);

//接收客户端发送的数据报

server.receive(packet); // 阻塞式方法//阻塞等待 //无数据发送无阻塞，端口被占用

**byte**[] datas=packet.getData();

**int** len=packet.getLength(); //getLength()返回实际收到的数据的字节数

System.*out*.println(**new** String(datas, 0, len));

//关闭资源

server.close();

}

}

通过字节数组流ByteArrayInputStream、ByteArrayOutputStream与数据流DataInputStream、DataOutputStream联合使用可以传递基本数据类型。

 
通过字节数组流ByteArrayInputStream、ByteArrayOutputStream与数据流ObjectInputStream、ObjectOutputStream联合使用可以传递对象。

**UDP：对象的传递之Person类**

**import** java.io.Serializable;

**public** **class** Person **implements** Serializable{

    **private** **static** **final** **long** serialVersionUID = 1L;

    **int** age;

    String name;

    **public** Person(**int** age, String name) {

        **super**();

        **this**.age = age;

        **this**.name = name;

    }

    \@Override

    **public** String toString() {

        **return** "Person [age=" + age + ", name=" + name + "]";

    }

}

**UDP：对象的传递之客户端**

**import** java.io.ByteArrayOutputStream;

**import** java.io.ObjectOutputStream;

**import** java.net.DatagramPacket;

**import** java.net.DatagramSocket;

**import** java.net.InetSocketAddress;

 

**public** **class** Client {

    **public** **static** **void** main(String[] args) **throws** Exception {

        //创建要发送的对象

        Person person = **new** Person(18, "高淇");

        ByteArrayOutputStream bos = **new** ByteArrayOutputStream();

        ObjectOutputStream oos = **new** ObjectOutputStream(bos);

        oos.writeObject(person);

        //获取字节数组流中的字节数组（我们要发送的数据）

        **byte**[] b = bos.toByteArray();

        //必须告诉数据报包要发到哪台计算机的哪个端口，发送的数据以及数据的长度

        DatagramPacket dp = **new** DatagramPacket(b,b.length,**new** 

                                             InetSocketAddress("localhost",8999));

        //创建数据报套接字：指定发送信息的端口

        DatagramSocket ds = **new** DatagramSocket(9000);

        //发送数据报包

        ds.send(dp);

        //关闭资源

        oos.close();

        bos.close();

        ds.close();

    }

}  

**UDP：对象的传递之服务器端**

**import** java.io.ByteArrayInputStream;

**import** java.io.ObjectInputStream;

**import** java.net.DatagramPacket;

**import** java.net.DatagramSocket;

 

**public** **class** Server {

    **public** **static** **void** main(String[] args) **throws** Exception {

        //创建数据报套接字：指定接收信息的端口

        DatagramSocket ds = **new** DatagramSocket(8999);

        **byte**[] b = **new** **byte**[1024];

        //创建数据报包，指定要接收的数据的缓存位置和长度

        DatagramPacket dp = **new** DatagramPacket(b, b.length);

        //接收客户端发送的数据报

        ds.receive(dp); // 阻塞式方法

        //dp.getData():获取客户端发送的数据，返回值是一个字节数组

        ByteArrayInputStream bis = **new** ByteArrayInputStream(dp.getData());

        ObjectInputStream ois = **new** ObjectInputStream(bis);

        System.out.println(ois.readObject());

        //关闭资源

        ois.close();

        bis.close();

        ds.close();

    }

}
