**容器（集合：是有接口和实现类组成）：容器和数组的不同之处是，容器长度可变，用来存放对象的引用（数组存放基本类型？？？）**

1.  Collection（接口）

![IMG_256](media/9b5a0c624c3399d3c89fd5982458d856.png)

1.  List（接口）（有序：每个元素都有索引标记，顺序即插入顺序，可重复：满足
    e1.equals(e2)）

![IMG_256](media/3346738f32259817b9ed57672f41c746.png)

主要是set get方法

1.  ArrayList（方法/实现类）
    底层用数组（Object[]）实现。线程不安全，效率高（查询效率高，增删效率低）

2.  LinkedList：底层用双向链表实现。线程不安全，效率高(查询效率低，增删效率高)

3.  Vector：底层用数组实现。线程安全(增加了synchronized同步标记)，效率低

4.  Set（无序，不可重复，只能有一个null×
    只适用于HashSet，往set中加入元素，本质就是把这个元素作为key加入到了内部的map中）

    1.  HashSet(内部是使用HashMap实现（通过它来存储数据）)(HashSet本质就是一个简化版的HashMap)

    2.  TreeSet(不能放null)内部需要对存储的元素进行排序，因此，我们对应的类需要实现Comparable接口。这样，才能根据重写compareTo()方法比较对象之间的大小，才能进行内部排序。

>   新方法见书P263-264

1.  Map(没有继承Collection不重复 允许值对象为空)

>   采用“key-value”来存储我们（比较复杂）数据。

![](media/fcacd12c8935631bbf2c4ee95ceb92a4.png)

>   IMG_256

>   keySet()返回该集合中的所有key对象形成的Set集合

>   Values()返回该集合中所有值对象形成的Collection集合

1.  HashMap 底层采用了哈希表存储数据 键重复则键值对替换 线程不安全，效率高
    允许key或value为null。

2.  HashTable线程安全，效率低 不允许key或value为null。

3.  TreeMap 红黑二叉树 映射关系有一定顺序 键对象升序 不允许键对象为null

4.  Iterator（ 如果遇到遍历容器时，判断删除元素的情况，使用迭代器遍历!）

>   通过它，可以遍历容器中元素

>   Iterator.next()方法返回的是Object 所以要向下强制转型

>   List（for，迭代器）

**遍历List方法一：普通for循环**

| 1 2 3 4 | **for**(**int** i=0;i\<list.size();i++){//list为集合的对象名     String temp = (String)list.get(i);     System.out.println(temp);//System.out.println(list.get(i)) } |
|---------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|


**遍历List方法二：增强for循环(使用泛型!)**

| 1 2 3 | **for** (String temp : list) { System.out.println(temp); } |
|-------|------------------------------------------------------------|


**遍历List方法三：使用Iterator迭代器(1)**

| 1 2 3 4 | **for**(Iterator iter= list.iterator();iter.hasNext();){     String temp = (String)iter.next();     System.out.println(temp); } |
|---------|---------------------------------------------------------------------------------------------------------------------------------|


**遍历List方法四：使用Iterator迭代器(2)**

| 1 2 3 4 5 6 | Iterator  iter =list.iterator(); **while**(iter.hasNext()){     Object  obj =  iter.next();     iter.remove();//如果要遍历时，删除集合中的元素，建议使用这种方式！     System.out.println(obj); |
|-------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|


>   Set（迭代器，增强for循环）

**遍历Set方法一：增强for循环**

| 1 2 3 | **for**(String temp:set){ System.out.println(temp); } |
|-------|-------------------------------------------------------|


**遍历Set方法二：使用Iterator迭代器**

| 1 2 3 4 | **for**(Iterator iter = set.iterator();iter.hasNext();){     String temp = (String)iter.next();     System.out.println(temp); } |
|---------|---------------------------------------------------------------------------------------------------------------------------------|


>   Map（keySet和entrySet）

**遍历Map方法一：根据key获取value**

| 1 2 3 4 5 | Map\<key, values\> map = **new** HashMap\<key, value\>(); Set\<key\>  keySet =  map.keySet(); **//for**(key k : keySet){ //System.out.println(k); //}                                               |
|-----------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
|           |  **for** (Iterator\<key\> iterator =  keySet.iterator(); iterator.hasNext();) {             String key = (key)iterator.next();             System.out.println(key + "--" + map.get(key));         } |

**遍历Map方法二：使用entrySet**

| 1 2 3 4 | Set\<Map.Entry\<key, values\>\>  entrySet = map.entrySet(); **for** (Iterator\<Entry\<key, values\>\> iterator = entrySet.iterator(); iterator.hasNext();) {     Entry\<key, values\> e = (Entry\<key, values\>) iterator.next();      System.out.println(e.getKey()+"--"+e.getValue()); |
|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|


1.  泛型（通过泛型将错误提前，保证程序稳定性和更高的可读性）：

它可以帮助我们建立类型安全的集合。在使用了泛型的集合中，遍历时不必进行强制类型转换（泛型之前都是向上/向下转型）。 泛型的本质就是“数据类型的参数化”。
我们可以把“泛型”理解为数据类型的一个占位符(形式参数)，即告诉编译器，在调用泛型时必须传入实际类型。JDK提供了支持泛型的编译器，将运行时的类型检查提前到了编译时执行，提高了代码可读性和安全性。

1.  class 类名\<T\> T可以用来声明数组类型T[] array T只能是类类型

2.  class 类名\<T,E,V\>

3.  限制泛型class 类名\<T extends anyClass\> anyClass指接口/类

4.  类型通配符 泛型类名称\<？extends anyClass\> 可以用在方法形参里
    A\<?\>=A\<?Object\>

>   限制泛型和使用通配符的区别：使用通配符声明的名称实例化的对象不能对其加入新的信息，只能获取或删除。set()×

>   5.向下extends也可以向上super

1.  Collections工具类（排序/查找）

. void sort(List) //对List容器内的元素排序，排序的规则是按照升序进行排序。

      2. void shuffle(List) //对List容器内的元素进行随机排列。

      3. void reverse(List) //对List容器内的元素进行逆续排列 。

      4. void fill(List, Object) //用一个特定的对象重写整个List容器。

      5. int binarySearch(List,
Object)//对于顺序的List容器，采用折半查找的方法查找特定对象。

哈希表（数组+链表）：

![IMG_256](media/60064eb152707799667d8fce5ab96221.png)

Entry[] table 就是HashMap的核心数组结构，我们也称之为“位桶数组”
