**常用类：**

1.  包装类（Wrapper Class）

>   实现了基本数据类型（非“纯面向对象”）和对象的互相转化（也实现了字符串和数字之间的转换）。

![](media/eb22ae6209c2e8cc562f5bbb3f510377.png)

>   IMG_256

![](media/e981911afb1c5bb9cf38746f333bb1b1.png)

>   IMG_256

![](media/b8bbae44e10813c63d6ff95a3fe783bc.png)

>   IMG_256

>   应该还有byteValue（）；shortValue（）；

注意点：

// 基本类型转化成Integer对象

        Integer int1 = **new** Integer(10);//Integer int1 = **new** Integer(“10”)//字符串转换成对象

        Integer int2 = Integer.valueOf(20); // 官方推荐这种写法 自动装箱

   // 字符串转化成Integer对象

        Integer int3 = Integer.parseInt("334");//将String型参数解析成等价的整数值
“ab334”

        // Integer对象转化成字符串

        String str1 = int3.toString();//Integer类中的toString()，返回一个表示该Integer值的String对象

>   作用：

>   1.
>   作为和基本数据类型对应的类型存在，方便涉及到对象的操作，如Object[]、集合（泛型）等的操作。

>   2.
>   包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法(这些操作方法的作用是在基本数据类型、包装类对象、字符串之间提供相互之间的转化!)。

>   Integer和int区别：

>   1、Integer默认值是null，而int默认值是0；

>   2、声明为Integer的变量需要实例化，而声明为int的变量不需要实例化；

>   3、Integer是对象，用一个引用指向这个对象；而int是基本类型，直接存储数值

>   4.Integer.TYPE与int.class相同

>   JDK1.5后

>   自动装箱(autoboxing)、自动拆箱(unboxing)（“编译器蜜糖(Compiler
>   Sugar)”）：将基本数据类型和包装类之间进行自动的互相转换。

>   自动装箱：

>         基本类型的数据处于需要对象的环境中时，会自动转为“对象”。

      Integer i = 100;//自动装箱

//相当于编译器自动为您作以下的语法编译：

Integer i = Integer.valueOf(100);//调用的是valueOf(100)，而不是new Integer(100)

>   自动拆箱：

>         每当需要一个值时，对象会自动转成基本数据类型。

Integer i = 100;

**int** j = i;//自动拆箱

//相当于编译器自动为您作以下的语法编译：

**int** j = i.intValue(); 

>      
>     自动装箱过程是通过调用包装类的valueOf()方法实现的，而自动拆箱过程是通过调用包装类的
>   xxxValue()方法实现的。   

>   包装类空指针异常问题

**public** **class** Test1 {

    **public** **static** **void** main(String[] args) {

        Integer i = **null**;//Integer i = Integer.valueOf(null);

        **int** j = i;//**int** j = i.intValue(); // null表示i没有指向任何对象的实体,所以也就不可能操作intValue()方法

    }

}

>   包装类缓存问题：

![](media/10d6e29ee2bcef728cccc1fefacc864d.png)

>   IMG_256

>   1234通过new调用包装类的构造方法来创建对象

 System.out.println(in3 == in4);//false 因为1234不在缓存范围内

 System.out.println(in3.equals(in4));//true//这里的equals（）被重写//比较的对象的值
同String

1.  String/StringBuilder/StringBuffer

>   String:不可变字符序列(源代码final)

>   1. String类的下述方法能创建并返回一个新的String对象: concat()、
>   replace()替换、substring()截取、 toLowerCase()、
>   toUpperCase()、trim()去空格。

>       2. 提供查找功能的有关方法: endsWith()判断字符串结尾、 startsWith()、
>   indexOf()字符串位置、lastIndexOf()。

>         3. 提供比较功能的方法:
>   equals()内容、equalsIgnoreCase()、compareTo()按字典顺序比较。

>         4. 其它方法: charAt() 、length()、split()字符串分割。

>   StringBuilder（字符串生成器）：可变字符序列，线程不安全，效率高(一般用它)。

>   1. 重载的public StringBuilder append(…)方法

>           可以为该StringBuilder 对象添加字符序列，仍然返回自身对象。

>         2. 方法 public StringBuilder delete(int start,int end)

>           可以删除从start开始到end-1为止的一段字符序列，仍然返回自身对象。

>         3. 方法 public StringBuilder deleteCharAt(int index)

>           移除此序列指定位置上的 char，仍然返回自身对象。

>         4. 重载的public StringBuilder insert(…)方法

>           可以为该StringBuilder 对象在指定位置插入字符序列，仍然返回自身对象。

>         5. 方法 public StringBuilder reverse()

>           用于将字符序列逆序，仍然返回自身对象。

>         6. 方法 public String toString() 返回此序列中数据的字符串表示形式。

>   StringBuffer：可变字符序列，线程安全，效率低

1.  时间：Date、DateFormat、Calendar

![IMG_256](media/de4b21a30f444d0f127775ff854399b9.png)

>   Date：使用毫秒数来表示我们的时间概念

>   **import** java.util.Date;

>   书上：Date date=new Date();

String s=String.format(“格式化转换符”，date);

>   DateFormat(抽象类)：实现Date对象跟String对象的互相转化（根据**指定格式**互相转化）

>    把时间对象转化成指定格式的字符串。反之，把指定格式的字符串转化成时间对象。

>   **import** java.text.SimpleDateFormat;

SimpleDateFormat s1 = **new** SimpleDateFormat(""yyyy-MM-dd hh:mm:ss"");

        String daytime = s1.format(**new** Date());

System.out.println(daytime);

![](media/5fb818130c55b2ca04630847757afdf2.png)

>   IMG_256

 将符合指定格式的字符串转成成时间对象.字符串格式需要和指定格式一致。

        String time = "2007-10-7";//time = "2007-10-7 20:15:30";

        Date date = s2.parse(time);

>   Calendar(抽象类)：
>   日期类。实现了将人的日期的概念跟Date的互相转化（通过它算日期
>   实际上还是算Date）

1.  File( java.io.File)

>   代表文件或者目录的一个抽象

>   常见构造方法：public File(String pathname)

>      
>    以pathname为路径创建File对象，如果pathname是相对路径，则默认的当前路径在系统属性user.dir（本项目的目录）中存储

  System.out.println(System.getProperty("user.dir"));//getProperty()得到系统的各种属性；

        File f = **new** File("a.txt"); //相对路径：默认放到user.dir目录下面

        f.createNewFile();//创建文件

        File f2 = **new** File("d:/b.txt");//绝对路径

        f2.createNewFile();

![](media/4ed8e5691ed3149700dc9498f337f0a9.png)

>   IMG_256

>   方法：

![](media/887843f53f430d7a993030aa8dd0887c.png)

>   IMG_256

>   通过File对象创建空文件或目录(在该对象所指的文件或目录不存在的情况下)：

![](media/b6ef13aa820ef2b5e775684e0015fc56.png)

>   IMG_256

1.  Math（数学类java.lang.Math）：其方法的参数和返回值类型一般为double型

1.产生[0, 1)之间的double类型的随机数的方法Math.random()

>   2.java.util.Random，实例化一个Random对象创建一个随机数生成器

>   Random r=new Random(seedValue随机数生成器的种子可不加)

>   r.nextInt(Int n)返回大于等于0且小于n的随机整数

>   补充：大数字运算
>   java.math.BigInteger（大整数）/java.math.BigDecimal（大小数）

数字格式化 java.text.DecimalFormat

1.  枚举(可以取代以往定义常量的方式，同时枚举类型还赋予程序在编译时进行检查的功能)

>   如果我们要定义一组常量，建议使用枚举。

>   不要学习和使用枚举的高级特性。(很容易被普通代替)

>   枚举类型的定义包括枚举声明和枚举体

**enum**  枚举名 {

      枚举体（常量列表）

}

>   所有的枚举类型隐性地继承自
>   java.lang.Enum。枚举实质上还是类!而每个被枚举的成员实质就是一个枚举类型的实例，他们默认都是public
>   static final修饰（接口中）的。可以直接通过枚举类型名使用它们。
