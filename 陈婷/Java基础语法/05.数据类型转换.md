# 05.数据类型转换
## 数据类型转换
### 1 自动转换（隐式）
一个<kbd>int</kbd>类型变量和一个<kbd>byte</kbd>类型变量进行加法运算：
```Java
public static void main(String[] args){
    int i = 1;
    byte b = 2;
    int j = i + b;
    System.out.println(j);
}

```
运算结果的，变量的类型是<kbd>int</kbd>，即*数据类型会发生自动类型转换*。
* **自动转换规则**：将<kbd>取值范围小的类型</kbd>自动提升为<kbd>取值范围大的类型</kbd>。
同理，当一个<kbd>int</kbd>类型变量和一个<kbd>double</kbd>变量运算时，<kbd>int</kbd>类型会自动提升为<kbd>double</kbd>类型进行运算。
```Java
public static void main(String[] args){
    int i = 1;
    double d = 2.5;
    double e = d + i;
    System.out.println(e);
}
```
#### 转换规则
范围较小的类型向范围大的类型提升，<kbd>byte, short, char</kbd>运算时提升为<kbd>int</kbd>。
```Java
byte, short, char-->int-->long-->float-->double
```
### 2 强制转换（显式）
* 强制类型转换：将<kbd>取值范围大的类型</kbd>转换成<kbd>取值范围小的类型</kbd>。
  * 自动转换是Java自动执行的，强制转换需要手动执行。
**转换格式**：
```
数据类型 变量名 = （数据类型）被转换的数据；
```
**eg**:
```Java
// double 类型数据强制转换成int类型，直接去掉小数点。
int i = (int)1.5;
```
```Java
public static void main(String[] args){
    // short类型变量，内存中2个字节
    short s = 1;
    /*
      出现编译失败
      s和1做运算的时候，1是int类型，s会被提升为int类型
      s+1后的结果是int类型，将结果再赋值回short类型时发生错误
      short内存2个字节，int类型4个字节
      必须将int强制转换为short才能完成
    */
    s = s + 1;  //编译失败
    s = (short)(s+1); //编译成功
}
```
#### 注意：
* 浮点数转换成整数，直接取消小数点，可能造成数据损失精度。
* <kbd>int</kbd>强制转换成<kbd>short</kbd>砍掉2个字节，可能造成数据丢失。
* <kbd>boolean</kbd>类型不能发生数据类型转换。
### 3 ASCII编码表
```Java
public static void main(String[] args){
    // 字符类型变量
    char c = 'a';
    int i = 1;
    // 字符类型和int类型计算
    System.out.println(c+i); // 输出结果是98
}
```
* **编码表**：
  |**字符**|**数值**|
  |--------|--------|
  |0|48|
  |9|57|
  |A|65|
  |Z|90|
  |a|97|
  |z|122|
> ASCII码表： American Standard Code for Information Interchange, 美国信息交换标准代码。
> Unicode码表： 万国码，开头0-127部分和ASCII完全一样，从128开始包含更多字符。