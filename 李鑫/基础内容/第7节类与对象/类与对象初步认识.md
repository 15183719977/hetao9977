# 类与对象  

**Java是面向对象的程序设计语言，类是面向对象的重要内容，可以把类当成一种自定义类型，可以使用类来定义变量，这种类型的变量统称为引用变量。也就是说，所有类是引用类型。**  

## 类  

> **类（class）** 是某一批对象的抽象；**对象（object）** 是一个具体存在的实体。  

定义类的简单语法如下所示：

```Java
[修饰符] class 类名
{
    /*零个或多个构造器定义*/
    /*零个或多个成员变量*/
    /*零个或多个方法*/
}
```

上面的语法格式中，修饰符可以是public，final，abstract，也可以忽略不写，类名只要满足标识符的合法性就可以了。

对一个类定义时，一般包含三种成员：**构造器、成员变量、方法**。成员变量用于定义该类或该类的实例所包含的状态数据，方法则用于定义该类或该类的实例的行为特征或者功能实现。构造器用于构造该类的实例，Java语言通过new关键字来调用构造器，从而返回该类的实例。类里各成员之间的定义顺序没有任何影响，各成员之间可以相互调用。

> **注意：** static修饰的成员不能访问没有static修饰的成员！  

成员变量、方法、构造器的定义的语法格式如下：  

```Java
[修饰符] 类型 成员变量名 [= 默认值];

[修饰符] 方法返回值类型 方法名(形参列表)
{
    /*...*/
}

[修饰符] 构造器名(形参列表)
{
    /*...*/
}
```

* 成员变量修饰符：可以省略，也可以是public、protected、private、static、final，其中public、protected、private三个最多只能出现其中之一，可以与static、final组合起来修饰成员变量。

* 方法修饰符：可以省略，也可以是public、protected、private、static、final、abstract，其中public、protected、private三个最多只能出现其中之一；abstract和final最多只能出现其中之一，它们可以与static组合起来修饰方法。

* 构造器修饰符：可以省略，也可以是public、protected、private其中之一。

> **注意：** 构造器既不能定义返回值类型，也不能使用void声明构造器。如果为构造器定义了返回值类型，或使用void声明构造器没有返回值，编译时不会出错，但Java会把这个所谓的构造器当成方法来处理——它就不再是构造器。  

## 对象  

创建对象的根本途径是构造器，通过new关键字来调用某个类的构造器即可创建这个类的实例。  

```Java
// 使用Person类定义并初始化一个Person类型的变量
Person p = new Person();
```

### this  

Java提供了一个this关键字，this关键字总是指向调用该方法的对象。this作为对象的默认引用有两种情形：

* 构造器中引用该构造器正在初始化的对象。

* 在方法中引用调用该方法的对象。

this关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。  
假设定义了一个Dog类，这个Dog对象的run()方法需要调用它的jump()方法，代码如下：

```Java
public class Dog
{
    // 定义一个jump方法
    public void jump()
    {
        System.out.println("正在执行jump方法");
    }

    // 定义一个run方法
    public void run()
    {
        Dog d = new Dog();
        d.jump();
        System.out.println("正在执行run方法");
    }
}
```

下面再提供一个程序来创建Dog对象，并调用该对象的run()方法。  

```Java
public class DogTest
{
    public static void main(String[] args)
    {
        Dog dog = new Dog();
        dog.run();
    }
}
```

在上面的程序中，一共产生了两个Dog对象，在Dog类的run()方法中，程序创建了一个Dog对象，并使用名为d的引用变量来指向该Dog对象；在DogTest的main()方法中，程序再次创建了一个Dog对象，并使用名为dog的引用变量来指向该Dog对象。首先调用run方法必须创建一个Dog对象，因此在run方法中调用jump方法不需要再创建一个新的Dog对象，其run方法修改如下：

```Java
public void run()
{
    this.jump();
    System.out.println("正在执行run方法");
}
```  

Java允许对象的一个成员直接调用另一个成员，可以省略this前缀。也就是说，将上面的run()方法改为如下形式也完全正确。

```Java
public void run()
{
    jump();
    System.out.println("正在执行run方法");
}
```  

> **注意：** 如果在static修饰的方法中使用this关键字，则这个关键字就无法指向合适的对象。所以，static修饰的方法中不能使用this引用。由于static修饰的方法不能使用this引用，所以static修饰的方法不能访问不使用static修饰的普通成员，因此Java语法规定：静态成员不能直接访问非静态成员。

当this作为对象的默认引用使用时，程序可以像访问普通引用变量一样来访问这个this引用，甚至可以把this当成普通方法的返回值。

```Java
public class ReturnThis
{
    public int age;
    public ReturnThis grow()
    {
        age++;
        return this;
    }
    public static void main(String[] args) {
        ReturnThis rt = new ReturnThis();
        rt.grow().grow().grow();
        System.out.println("rt的age成员变量值是：" + rt.age);
        // output: age = 3
    }
}
```  

## 成员变量与局部变量  

成员变量指的是在类里定义的变量；局部变量指的是在方法里定义的变量。

类变量与实例变量统称为成员变量。当使用该类的实例访问类变量时，如果修改了类变量的值，由于这个类变量并不属于这个实例，而是它对应的类。因此，修改的依然是类的类变量，与通过该类来修改类变量的结果完全相同，这会导致该类的其他实例来访问这个类变量时也将获得这个被修改过的值。

```Java
public class Person
{
    public String name;  // 实例变量
    public static int eyeNum;  // 类变量

    public static void main(String[] args) {
        System.out.println("Person类的eyeNum类变量值：" + Person.eyeNum);  // output Person.eyeNum = 0

        Person p = new Person();
        p.name = "小李";
        p.eyeNum = 2;

        System.out.println("对象p的name变量值为：" + p.name + "，对象p的eyeNum变量值为：" + p.eyeNum);  // output 小李 2
        System.out.println("Person的eyeNum变量值：" + Person.eyeNum);  // output 2

        Person p2 = new Person();
        System.out.println("对象p2的eyeNum变量值为：" + p2.eyeNum);  // output 2

    }
}
```

### 成员变量的初始化和内存中的运行机制

