# 类与对象  

**Java是面向对象的程序设计语言，类是面向对象的重要内容，可以把类当成一种自定义类型，可以使用类来定义变量，这种类型的变量统称为引用变量。也就是说，所有类是引用类型。**  

## 类  

> **类（class）** 是某一批对象的抽象；**对象（object）** 是一个具体存在的实体。  

定义类的简单语法如下所示：

```Java
[修饰符] class 类名
{
    /*零个或多个构造器定义*/
    /*零个或多个成员变量*/
    /*零个或多个方法*/
}
```

上面的语法格式中，修饰符可以是public，final，abstract，也可以忽略不写，类名只要满足标识符的合法性就可以了。

对一个类定义时，一般包含三种成员：**构造器、成员变量、方法**。成员变量用于定义该类或该类的实例所包含的状态数据，方法则用于定义该类或该类的实例的行为特征或者功能实现。构造器用于构造该类的实例，Java语言通过new关键字来调用构造器，从而返回该类的实例。类里各成员之间的定义顺序没有任何影响，各成员之间可以相互调用。

> **注意：** static修饰的成员不能访问没有static修饰的成员！  

成员变量、方法、构造器的定义的语法格式如下：  

```Java
[修饰符] 类型 成员变量名 [= 默认值];

[修饰符] 方法返回值类型 方法名(形参列表)
{
    /*...*/
}

[修饰符] 构造器名(形参列表)
{
    /*...*/
}
```

* 成员变量修饰符：可以省略，也可以是public、protected、private、static、final，其中public、protected、private三个最多只能出现其中之一，可以与static、final组合起来修饰成员变量。

* 方法修饰符：可以省略，也可以是public、protected、private、static、final、abstract，其中public、protected、private三个最多只能出现其中之一；abstract和final最多只能出现其中之一，它们可以与static组合起来修饰方法。

* 构造器修饰符：可以省略，也可以是public、protected、private其中之一。

> **注意：** 构造器既不能定义返回值类型，也不能使用void声明构造器。如果为构造器定义了返回值类型，或使用void声明构造器没有返回值，编译时不会出错，但Java会把这个所谓的构造器当成方法来处理——它就不再是构造器。  

## 对象  

创建对象的根本途径是构造器，通过new关键字来调用某个类的构造器即可创建这个类的实例。  

```Java
// 使用Person类定义并初始化一个Person类型的变量
Person p = new Person();
```

### this  

Java提供了一个this关键字，this关键字总是指向调用该方法的对象。this作为对象的默认引用有两种情形：

* 构造器中引用该构造器正在初始化的对象。

* 在方法中引用调用该方法的对象。

this关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。  
假设定义了一个Dog类，这个Dog对象的run()方法需要调用它的jump()方法，代码如下：

```Java
public class Dog
{
    // 定义一个jump方法
    public void jump()
    {
        System.out.println("正在执行jump方法");
    }

    // 定义一个run方法
    public void run()
    {
        Dog d = new Dog();
        d.jump();
        System.out.println("正在执行run方法");
    }
}
```

下面再提供一个程序来创建Dog对象，并调用该对象的run()方法。  

```Java
public class DogTest
{
    public static void main(String[] args)
    {
        Dog dog = new Dog();
        dog.run();
    }
}
```

在上面的程序中，一共产生了两个Dog对象，在Dog类的run()方法中，程序创建了一个Dog对象，并使用名为d的引用变量来指向该Dog对象；在DogTest的main()方法中，程序再次创建了一个Dog对象，并使用名为dog的引用变量来指向该Dog对象。首先调用run方法必须创建一个Dog对象，因此在run方法中调用jump方法不需要再创建一个新的Dog对象，其run方法修改如下：

```Java
public void run()
{
    this.jump();
    System.out.println("正在执行run方法");
}
```  

Java允许对象的一个成员直接调用另一个成员，可以省略this前缀。也就是说，将上面的run()方法改为如下形式也完全正确。

```Java
public void run()
{
    jump();
    System.out.println("正在执行run方法");
}
```  

> **注意：** 如果在static修饰的方法中使用this关键字，则这个关键字就无法指向合适的对象。所以，static修饰的方法中不能使用this引用。由于static修饰的方法不能使用this引用，所以static修饰的方法不能访问不使用static修饰的普通成员，因此Java语法规定：静态成员不能直接访问非静态成员。

当this作为对象的默认引用使用时，程序可以像访问普通引用变量一样来访问这个this引用，甚至可以把this当成普通方法的返回值。

```Java
public class ReturnThis
{
    public int age;
    public ReturnThis grow()
    {
        age++;
        return this;
    }
    public static void main(String[] args) {
        ReturnThis rt = new ReturnThis();
        rt.grow().grow().grow();
        System.out.println("rt的age成员变量值是：" + rt.age);
        // output: age = 3
    }
}
```  

## 成员变量与局部变量  

成员变量指的是在类里定义的变量；局部变量指的是在方法里定义的变量。

类变量与实例变量统称为成员变量。当使用该类的实例访问类变量时，如果修改了类变量的值，由于这个类变量并不属于这个实例，而是它对应的类。因此，修改的依然是类的类变量，与通过该类来修改类变量的结果完全相同，这会导致该类的其他实例来访问这个类变量时也将获得这个被修改过的值。

```Java
public class Person
{
    public String name;  // 实例变量
    public static int eyeNum;  // 类变量

    public static void main(String[] args) {
        System.out.println("Person类的eyeNum类变量值：" + Person.eyeNum);  // output Person.eyeNum = 0

        Person p = new Person();
        p.name = "小李";
        p.eyeNum = 2;

        System.out.println("对象p的name变量值为：" + p.name + "，对象p的eyeNum变量值为：" + p.eyeNum);  // output 小李 2
        System.out.println("Person的eyeNum变量值：" + Person.eyeNum);  // output 2

        Person p2 = new Person();
        System.out.println("对象p2的eyeNum变量值为：" + p2.eyeNum);  // output 2

    }
}
```

当代码第一次使用某个类时，系统通常会在这个时候加载这个类，并初始化这个类。在类的准备阶段，系统会为该类的**类变量**分配内存空间，并指定默认初始值。

局部变量定义后，必须经过**显式初始化**后才能使用，系统不会为局部变量执行初始化。这意味着定义局部变量后，系统并未为这个变量分配内存空间，直到等到程序为这个变量赋初始值时，系统才会为局部变量分配内存，并将初始值保存到这块内存中。  

## 隐藏和封装

**封装（Encapsulation）** 指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，而是通过该类所提供的方法来实现对内部信息的操作和访问。其目的如下：

* 隐藏类的实现细节

* 让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里加入控制逻辑，限制对成员变量的不合理访问。

* 可进行数据检查，从而有利于保证对象信息的完整性。

* 便于修改，提高代码的可维护性。

封装使用Java提供的**访问控制符**来实现，主要从以下两个方面考虑：

1. 将对象的成员变量和实现细节隐藏起来，不允许外部直接访问。

2. 把方法暴露出来，让方法来控制对这些成员变量进行安全的访问和操作。  

### 访问控制符  

Java提供了3个访问控制符：private、protected和public，分别代表了3个访问控制级别，另外还有一个不加任何访问控制符的访问控制级别，提供了4个访问控制级别。访问级别由小到大：**private->default->protected->public**。

* private（**当前类**访问权限）：如果类里的一个成员（包括成员变量、方法和构造器等）使用private访问控制符来修饰，则这个成员只能在当前类的内部被访问。很显然，这个访问控制符用于修饰成员变量最合适，使用它来修饰成员变量就可以把成员变量隐藏在该类的内部。

* default（**包**访问权限）：如果类里的一个成员（包括成员变量、方法和构造器等）或者一个外部类不使用任何访问控制符修饰，就称它是包访问权限的，default访问控制的成员或外部类可以被相同包下的其他类访问。

* protected（**子类**访问权限）：如果一个成员（包括成员变量、方法和构造器等）使用protected访问控制符修饰，那么这个成员既可以被同一个包中的其他类访问，也可以被不同包中的子类访问。在通常情况下，如果使用protected来修饰一个方法，**通常是希望其子类来重写这个方法**。

* public（**公共**访问权限）：这是一个最宽松的访问控制级别，如果一个成员（包括成员变量、方法和构造器等）或者一个外部类使用public访问控制符修饰，那么这个成员或外部类就可以被所有类访问，不管访问类和被访问类是否处于同一个包中，是否具有父子继承关系。

|   | private | default | protected | public |
| :-: | :-: |:-: |:-: |:-: |
| 同一个类中| ✔ | ✔ |✔ |✔ |
| 同一个包中|  | ✔ |✔ |✔ |
| 子类中|  |  |✔ |✔ |
| 全局范围内|  |  | |✔ |  


> **注意：** 如果一个Java源文件里定义的所有类都没有使用public修饰，则这个Java源文件的文件名可以是一切合法的文件名；但如果一个Java源文件里定义了一个public修饰的类，则这个源文件的文件名必须与public修饰的类的类名相同。

## package  

Java引入了包（package）机制，提供了类的多层命名空间，用于解决类的命名冲突、类文件管理等问题。

```Java
package packagename;
```

> **注意：** 把生成的class文件放在某个目录下，这个目录名就成了这个类的包名。这是一个错误的看法，不是有了目录结构，就等于有了包名。为Java类添加包必须在Java源文件中通过package语句指定，单靠目录名是没法指定的。Java的包机制需要两个方面保证：① 源文件里使用package语句指定包名；② class文件必须放在对应的路径下。

为了简化编程，Java引入了import关键字，import可以向某个Java文件中导入指定包层次下某个类或全部类，import语句应该出现在package语句（如果有的话）之后、类定义之前。一个Java源文件只能包含一个package语句，但可以包含多个import语句，多个import语句用于导入多个包层次下的类。

```Java
import package.subpackage...ClassName;  // 某一个类
import package.subpackage...*;  // 包下的全部类
```

> **注意：** Java默认为所有源文件导入java.lang包下的所有类，因此前面在Java程序中使用String、System类时都无须使用import语句来导入这些类。但对于前面介绍数组时提到的Arrays类，其位于java.util包下，则必须使用import语句来导入该类。

### import static

**静态导入**用于导入指定类的某个静态成员变量、方法或全部的静态成员变量、方法。

```Java
 // 导入指定类的单个静态成员变量、方法
 import static package.subpackage...ClassName.filedName | methodName;

 // 导入指定类的全部静态成员变量、方法
 import static package.subpackage...ClassName.*;
```

## 构造器  

当程序员调用构造器时，系统会先为该对象分配内存空间，并为这个对象执行默认初始化，这个对象已经产生了——这些操作在构造器执行之前就都完成了。也就是说，当系统开始执行构造器的执行体之前，系统已经创建了一个对象，只是这个对象还不能被外部程序访问，只能在该构造器中通过this来引用。当构造器的执行体执行结束后，这个对象作为构造器的返回值被返回，通常还会赋给另一个引用类型的变量，从而让外部程序可以访问该对象。