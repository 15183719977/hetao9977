# Java中的类型转换

## 自动类型转换
> 如果系统支持把某种基本类型的值直接赋给另一种基本类型的变量，则这种方式被称为自动类型转换。自动类型转换是由小到大的转换，byte->short(char)->int->long->float->double，其中，byte类型不能自动转换位char类型。

**代码示例**
```
public class AutoConverrsion
{
    public static void main(String[] args)
    {
        int a = 6;
        // int类型可以自动转换位float类型
        float f = a;
        byte b = 9;
        // 下面的代码将出错，byte类型不能自动转换为char类型
        // char c = b;
        // byte类型可以自动转换为double类型
        double d = b;
    }
}
```
**字符串类型的自动转换**
> 当把任何基本类型的值和字符串值进行连接运算时，基本类型的值将自动类型转换为字符串类型。

**代码示例**
```
public class AutoConverrsionToString
{
    public static void main(String[] args)
    {
        // 一个基本类型的值和字符串进行连接运算(+)时，基本类型的值自动转换为字符串
        String str1 = 3.5f + "";
        // 下面语句打印7Hello！
        System.out.println(3 + 4 + "Hello！");
        // 下面语句打印Hello!34
        System.out.prrintln("Hello！" + 3 + 4);
    }
}
```
## 强制类型转换
> 要将byte->short(char)->int->long->float->double中的箭头反向，必须进行强制转换，强制类型转换的语法格式是：(targetType)value，强制类型转换的运算符是圆括号“()”。当进行强制类型转换时，类似于把一个大瓶子里的水倒入一个小瓶子，如果大瓶子里的水不多还好，但如果大瓶子里的水很多，将会引起溢出，从而造成数据丢失。这种转换也被称为“缩小转换（NarrowConversion）”。

**代码示例**
```
public class NarrowConversion
{
     public static void main(String[] args)
     {
         int iValue =  233;
         // 强制把一个int类型的值转换为byte类型
         byte bValue = (byte) iValue;
         // bValue = -23
         double dValue = 3.98;
         // 强制把一个double类型的值转换为int类型的值
         int tol = (int) dValue;
         // tol = 3
     }
}
```
在上面的程序中，把一个浮点数强制转换为整数时，Java将直接截断浮点数的小数部分。在将int类型233强制转换为byte类型时，变成了-23，这就是溢出。如下所示。
```
/*32位的int类型*/
0000 0000 0000 0000 0000 0000 1110 1001 = 233
/*8位的byte类型，截断int类型的高24位*/
1110 1001 = -23
```
还有下面一行容易出错的代码：
```
// 直接将5.6赋值给float类型变量将出现错误，因为5.6默认是double类型
float a = 5.6;
```
上面代码中的5.6默认是一个double类型的浮点数，因此将5.6赋值给一个float类型变量将导致错误，必须使用强制类型转换才可以，即将上面代码改为`float a = (float) 5.6;`

在通常情况下，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型。例如，把字符串转换成int类型，则可通过如下代码实现：
```
String a = "45";
// 使用Integer.parseInt(a);
```
Java为8种基本类型都提供了对应的包装类：boolean对应Boolean、byte对应Byte、short对应Short、int对应Integer、long对应Long、char对应Character、float对应Float、double对应Double，8个包装类都提供了一个parseXxx(String str)静态方法用于将字符串转换成基本类型。

## 表达式类型的自动提升
当一个算术表达式中包含多个基本类型的值时，整个算术表达式的数据类型将发生自动提升。Java定义了如下的自动提升规则。
* 所有的byte类型、short类型和char类型将被提升到int类型。
* 整个算术表达式的数据类型自动提升到与表达式中最高等级操作数同样的类型。
  
**代码示例**
```
// 下面代码是一个典型的错误
short sValue = 5;
sValue = sValue - 2;
```
上面的代码中，上面的“sValue-2”表达式的类型将被提升到int类型，这样就把右边的int类型值赋给左边的short类型变量，从而引起错误。

如果表达式中包含了字符串，则又是另一番情形了。因为当把加号（+）放在字符串和基本类型值之间时，这个加号是一个字符串连接运算符，而不是进行加法运算。

**代码示例**
```
//输出字符串Hello！a7
System.out.println("Hello！" + 'a' + 7);
//输出字符串104Hello！
System.out.println('a' + 7 + "Hello！");
```
对于第一个表达式“"Hello！"+'a'+7”，先进行“"Hello！"+'a'”运算，把'a'转换成字符串，拼接成字符串Hello！a，接着进行“"Hello！a"+7”运算，这也是一个字符串连接运算，得到结果是Hello！a7。对于第二个表达式，先进行“'a'+7”加法运算，其中'a'自动提升到int类型，变成a对应的ASCII值：97，从“97+7”将得到104，然后进行“104+"Hello！"”运算，104会自动转换成字符串，将变成两个字符串的连接运算，从而得到104Hello！。