# 数组

> 数组是编程语言中最常见的一种数据结构，可用于存储多个数据，每个数组元素存放一个数据，通常可通过数组元素的索引来访问数组元素，可以读取或者修改数组元素的值。

## 理解Java中的数组

Java的数组要求所有的数组元素具有相同的数据类型，因此，一个数组中，数组元素的类型是唯一的。但是Java语言是面向对象的语言，类与类之间支持继承关系，这样可能产生一个数组里可以存放多种数据类型的假象。例如有一个水果数组，要求每个数组元素都是水果，实际上数组元素既可以是苹果，也可以是香蕉，因为苹果和香蕉都继承至水果这个类，但这个数组的数组元素类型还是唯一的，只能是水果类型。

一旦数组的初始化完成，数组在内存中所占的空间将被固定下来，因此数组的长度将不可改变。即使把某个数组元素的数据清空，但它所占的空间依然被保留，依然属于该数组，数组的长度依然不变。

Java的数组既可以存储基本类型的数据，也可以存储引用类型的数据，只要所有的数组元素具有相同的类型即可。

同时，数组本身也是一种数据类型，它本身为一种引用类型。例如int是一个基本类型，但int[]（这是定义数组的一种方式）就是一种引用类型了。

## 数组的定义与初始化

Java语言支持两种语法格式来定义数组：

```Java
type[] arrayName;
type arrayName[];
```

数组是一种引用类型的变量，因此使用它定义一个变量时，仅仅表示定义了一个引用变量（也就是定义了一个指针），这个引用变量还未指向任何有效的内存，因此定义数组时不能指定数组的长度。而且由于定义数组只是定义了一个引用变量，并未指向任何有效的内存空间，所以还没有内存空间来存储数组元素，因此这个数组也不能使用，只有对数组进行初始化后才可以使用。

***定义数组时不能指定数组的长度！***

Java语言中数组必须先初始化，然后才可以使用。所谓初始化，就是为数组的数组元素分配内存空间，并为每个数组元素赋初始值。不管以哪种方式来初始化数组，只要为数组元素分配了内存空间，数组元素就具有了初始值。初始值的获得有两种形式：一种由系统自动分配；另一种由程序员指定。

数组的初始化有如下两种方式。

* 静态初始化：初始化时由程序员显示地指定每个数组元素的初始值，由系统决定数组长度。
* 动态初始化：初始化时由程序员指定数组长度，由系统为数组元素分配初始值。
  
### 1.静态初始化

静态初始化的语法格式如下：

```Java
arrayName = new type[] {element1, element2, ...};
```

在上面的语法格式中，前面的type就是数组元素的数据类型，此处的type必须与定义数组变量时所使用的type相同，也可以是定义数组时所指定的type的子类，并使用花括号把所有的数组元素括起来，多个数组元素之间以英文逗号（,）隔开，定义初始化值的花括号紧跟[]之后。值得指出的是，执行静态初始化时，显式指定的数组元素值的类型必须与new关键字后的type类型相同，或者是其子类的实例。下面代码定义了使用这三种形式来进行静态初始化。

```Java
// 定义一个int数组类型的变量，变量名为intArr
int[] intArr;
// 使用静态初始化，初始化数组时只指定数组元素的初始值，不指定长度
intArr = new int[] {1, 2, 3, 4};
Object objArr1;
objArr1 = new String[] {"Hello", "World!"};
Object objArr2;
objArr2 = new Object[] {"Hello", "World!"};
```

因为Java语言是面向对象的编程语言，能很好地支持子类和父类的继承关系：子类实例是一种特殊的父类实例。在上面程序中，String类型是Object类型的子类，即字符串是一种特殊的Object实例。

除此之外，静态初始化还有如下的简化的语法格式：

```Java
type[] arrayName = {element1, element2, element3, ...};
```

在这种语法格式中，直接使用花括号来定义一个数组，花括号把所有的数组元素括起来形成一个数组。只有在定义数组的同时执行数组初始化才支持使用简化的静态初始化。

```Java
int[] a = {1, 2, 3, 4};
```

### 2.动态初始化

动态初始化只指定数组的长度，由系统为每个数组元素指定初始值。动态初始化的语法格式如下：

```Java
arrayName = new type[length];
```

在上面语法中，需要指定一个int类型的length参数，这个参数指定了数组的长度，也就是可以容纳数组元素的个数。与静态初始化相似的是，此处的type必须与定义数组时使用的type类型相同，或者是定义数组时使用的type类型的子类。

```Java
// 数组的定义与初始化同时完成
int[] prices = new int[5];
Object[] books = new String[4];
```

执行动态初始化时，程序员只需指定数组的长度，即为每个数组元素指定所需的内存空间，系统将负责为这些数组元素分配初始值。指定初始值时，系统按如下规则分配初始值:

* 数组元素的类型是基本类型中的整数类型（byte、short、int和long），则数组元素的值是0。
  
* 数组元素的类型是基本类型中的浮点类型（float、double），则数组元素的值是0.0。

* 数组元素的类型是基本类型中的字符类型（char），则数组元素的值是'\u0000'。

* 数组元素的类型是基本类型中的布尔类型（boolean），则数组元素的值是false。

* 数组元素的类型是引用类型（类、接口和数组），则数组元素的值是null。

> **注意:**
> 不要同时使用静态初始化和动态初始化，也就是说，不要在进行数组初始化时，既指定数组的长度，也为每个数组元素分配初始值。

## 数组的访问

访问数组元素都是通过在数组引用变量后紧跟一个方括号（[]），方括号里是数组元素的索引值，这样就可以访问数组元素了。

所有的数组都提供了一个length属性，通过这个属性可以访问到数组的长度，一旦获得了数组的长度，就可以通过循环来遍历该数组的每个数组元素。

```Java
// 使用for循环输出prices数组的每个数组元素的值
for (int i=0; i<prices.length; i++)
{
    System.out.println(prices[i]);
}
```

Java还提供了foreach循环，使用foreach循环遍历数组和集合元素时，无须获得数组和集合长度，无须根据索引来访问数组元素和集合元素，foreach循环自动遍历数组和集合的每个元素。语法格式如下：

```Java
for (type variableName : array | collection)
{
    // variableName自动迭代访问每个元素
}

// 示例
for (int price : preices)
{
    System.out.println(price);
}
```

> **注意:**
> 使用foreach循环迭代数组元素时，并不能改变数组元素的值，因此不要对foreach的循环变量进行赋值。

## 深入理解数组

> 数组是一种引用数据类型，数组引用变量只是一个引用，数组元素和数组变量在内存里是分开存放的。

数组引用变量只是一个引用，这个引用变量可以指向任何有效的内存，只有当该引用指向有效内存后，才可通过该数组变量来访问数组元素。这类似于C/C++中的数组，其数组变量是一个指针，指向数组的内存。

实际的数组对象被存储在堆（heap）内存中；如果引用该数组对象的数组引用变量是一个局部变量，那么它被存储在栈（stack）内存中。如果堆内存中数组不再有任何引用变量指向自己，则这个数组将成为垃圾，该数组所占的内存将会被系统的垃圾回收器回收。因此，为了让垃圾回收器回收一个数组所占的内存空间，可以将该数组变量赋为null，也就切断了数组引用变量和实际数组之间的引用关系，实际的数组也就成了垃圾。

#### 代码示例

```Java
public class ArrayInRam
{
    public static void main(String[] args)
    {
        // 定义并初始化数组
        int[] a = {5, 7, 9};
        int b = new int[4];
        // 因为a和b都是int[]类型，所以可以将a的值赋给b，即b指向a指向的数组内存，因此b最开始指向的数组将会被视为垃圾
        b = a;
    }
}
```

## 引用类型数组

引用类型数组的数组元素是引用，类似于C/C++的指针数组。我们定义一个Person类：
```Java
class Person
{
    public int age;  // 年龄
    public double height;  // 身高
    // 定义一个info方法
    public void info()
    {
        System.out.println("我的年龄是：" + age + "，我的身高是：" + height);
    }
}
```

再定义一个Person类型的数组，并初始化以及赋值：

```Java
    public class ReferenceArrayTest
    {
        public static void main(String[] args)
        {
            // 定义并初始化一个名为students的Person数组
            Person students = new Person[2];
            // 创建两个Person实例并给他们的属性赋值
            Person zhang = new Person();
            zhang.age = 15;
            zhang.height = 158;

            Person lee = new Person();
            lee.age = 16;
            lee.height = 161;

            studengs[0] = zhang;
            students[1] = lee;

            // 下面两句的输出一样
            lee.info();
            students[1].info();
        }
    }
```

程序在执行main方法的第一句时，在栈内存中定义了一个students变量，指向堆内存中的数组，每个数组元素的值都是一个引用，但其并未指向任何有效的地址，因此值都是null。接着定义的两个Person示例，分配了四块内存，在栈内存中定义了两个变量名，在堆内存中，定义了两个Person实例。当给students数组赋值后，数组元素分别指向堆内存中的Person实例，因此通过zhang和students[0]来访问Person实例的实例变量和方法的效果完全一样，不论修改students[0]所指向的Person实例的实例变量，还是修改zhang变量所指向的Person实例的实例变量，所修改的其实是同一个内存区，所以必然互相影响。

## 多维数组

Java语言里的数组类型是引用类型，因此数组变量其实是一个引用，这个引用指向真实的数组内存。数组元素的类型也可以是引用，如果数组元素的引用再次指向真实的数组内存，这种情形看上去很像多维数组。

前面定义数组类型的语法：type[] arrName;，这是典型的一维数组的定义语法，其中type是数组元素的类型。如果希望数组元素也是一个引用，而且是指向int数组的引用，则可以把type具体成int[]，如果把int这个类型扩大到Java的所有类型（不包括数组类型），则出现了定义二维数组的语法：

```Java
type[][] arrName;
```

接着对这个“二维数组”执行初始化，同样可以把这个数组当成一维数组来初始化，把这个“二维数组”当成一个一维数组，其元素的类型是type[]类型，则可以采用如下语法进行初始化：

```Java
arrName = new type[length][];
```

上面的初始化语法相当于初始化了一个一维数组，这个一维数组的长度是length。同样，因为这个一维数组的数组元素是引用类型（数组类型）的，所以系统为每个数组元素都分配初始值：null。

### 代码示例

```Java
public class TwoDimenssion
{
    public static void main(String[] args)
    {
        // 定义并初始化一个二维数组
        int[][] a = new int[4][];

        // 把a当成以为数组遍历
        for (int i=0; i<a.length; i++)
        {
            /*...*/
        }
    }
}
```