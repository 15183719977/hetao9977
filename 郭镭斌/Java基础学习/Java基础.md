# Java基础

## 一、数据类型

### 1、基本数据类型

Java有8种基础数据类型：byte、short、int、long这4中整型用于存放整数，char这1种字符类型用于存放**一个字符**（值用单引号表示），float、double这2种浮点数类型用于存放小数并且默认小数类型是double类型，boolean这一种布尔类型用于存放true或false默认值是false。

| 数据类型 | 缺省值 | 长度 | 范围         |
| -------- | ------ | ---- | ------------ |
| byte     | 0      | 8位  | -128~127     |
| short    | 0      | 16位 | -2^15~2^15-1 |
| int      | 0      | 32位 | -2^31~2^31-1 |
| long     | 0      | 64位 | -2^63~2^63-1 |
| char     |        | 16位 |              |
| float    | 0.0    | 32位 |              |
| double   | 0.0    | 64位 |              |
| boolean  | false  |      | true、false  |

创建一个Java对象需要使用到new关键字，但是给一个基本类型变量赋值确不需要new，因为基本类型是Java语言里内置的特殊数据类型，并不是某个类的对象，给基本类型赋值的值是**字面值**

当用L结尾时，一个整数字面值就是long类型，否则就是int类型，byte、short、int、long都可以用int类型来赋值，字面值有如下四种进制表示方式：

```java
int decVal = 20 //10进制
int hexVal = 0x1a //16进制
int oxVal = 032 //8进制
int binVal = 0b100101 //22进制
```

### 2、类型转换

不同的数据类型可以相互转化但得遵循一定规则：

精度高的数据类型就像容量大的杯子，可以放更大的数据
精度低的数据类型就像容量小的杯子，只能放更小的数据
小杯子往大杯子里倒东西，大杯子怎么都放得下
大杯子往小杯子里倒东西，有的时候放的下，有的时候就会有溢出

虽然short和char都是16位的，长度是一样的
但是彼此之间，依然需要进行强制转换

![](images\类型转换.png)

### 3、变量命名

Java中的变量只能用字母、数字、\_、$，并且变量的第一个字符只能使用字母、\_、$，不能使用数字

### 4、变量作用域

当一个变量被声明在类内部，该变量被称为字段、属性、成员变量、Field，在类中均可以访问到

当一个变量声明在方法上，该变量成为参数（也成为形参，传入的实际参数值称为实参，在函数体内修改形参值并不会修改实参值），在该方法内可以访问到，其他方法不能访问该参数，类内部也不能访问该参数

当一个变量声明在方法的内部，该变量叫局部变量，从声明开始位置到所处块（块经常用{}来界定）结束位置均可访问到

当访问到的变量被多个作用域影响时，按照**就近原则**

### 5、final变量

被final修饰的变量只有一次被赋值的机会

如果final修饰的是方法参数，在方法内部还能否给这个参数赋值？**不能**，因为在方法调用时，就会发生第一次赋值，则后面不能进行多次赋值。

注：final修饰的是基本数据类型参数，改参数在方法内不能被重新赋值；final修饰的是引用类型参数，该参数在方法内部不能再重新引用新的对象，但改参数所引用的对象的值是可以改变的。

### 6、表达式、块

以;结尾的一段代码，即为一个表达式，; 也是一个完整的表达式。

从{ 开始 到对应的} 结束，即一个块

## 二、操作符

### 1、算数操作符

+、-、*、/，如果有任何运算数的长度超过int，那么运算结果就按最长长度计算，如：

```java
int a = 5;
long b = 6;
a+b的结果类型是long型
```

如果任何运算数的长度都不超过int，那么运算结果就按int来计算

```java
byte a = 1;
byte b = 2;
a+b的结果类型是int型
```

%取余数，也称取模

### 2、逻辑运算符

&两侧都会被运算，&&第一个为false，第二个不会被运算

|两侧都会被运算，||第一个为true，第二个不会被运算

！取反，^异或

### 3、位操作符

|位或，&位与，^ 异或，~取反，<<左移，最后一位补0，>>带符号右移，如果是整数，前面补0,如果是负数，则除符号位之外其余的右移，最后符号位置1，>>>无符号右移，高位均补0

### 4、Scanner

在使用java.util.Scanner类进行键盘输入的时候，通过nextInt()读取整数后，再接着读取字符串往往会出现错误，读出来的往往是换行符“\r\n”，因为nextInt()仅仅读取数字信息，而不会读取换行符信息。如果需要读取了整数后，接着读取字符串，需要先执行一次nextLine()，取走换行符。

next()在输入有效字符之后输入的空格、tab、换行都是它的结束符，nextLine()的开始结束符只有换行，中间输入的空格、tab都会照常输出。

注：闰年的条件，（1）普通闰年：年份被4整除但不能被100整除，或者（2）世纪闰年：年份被400整除

## 三、控制流程

### 1、switch

switch可以使用byte、short、int、char、String、enum

### 2、do while

do{

}while();

与while循环的区别在于无论是否成立，先执行一次，再进行判断。

### 3、结束外部循环

(1)、在外部循环开始前定义一个boolean变量，在内部循环中修改这个变量的值，通过在外部循环中判断这个值，来结束外部循环

(2)、使用标签结束外部循环

```java
public class HelloWorld {
    public static void main(String[] args) {
        //遇到双数结束外部循环 
        outloop: //outloop这个标示是可以自定义
        for (int i = 0; i < 10; i++) {
            for (int j = 0; j < 10; j++) {
                System.out.println(i+":"+j);
                if(0==j%2) 
                    break outloop; //如果是双数，结束外部循环
            } 
        }    
    }
}
```

### 4、增强型for循环

增强型for循环只能用来取值，不能用来修改数组里的值

## 四、数组

数组是一个固定长度的，包含了相同类型数据的容器。

int[] a；仅声明了一个数组引用变量，不会创建数组。

创建数组的时候要指定数组的长度，如new int[5]；

length属性用于访问一个数组的长度。

数组可以分配空间与赋值分步进行：

```java
int[] arr = new int[4];
int[0] = 1;int[1] = 2;int[2] = 3;int[3] = 4;
```

也可以同时进行:

```java
int[] arr = new int[]{1,2,3,4};
或者 int[] arr = {1,2,3,4};
但是不能 int[] arr = new int[4]{1,2,3,4};//不能同时指定长度与赋值
```

数组的复制可以通过System.arraycopy(src, srcPos, dst, dstPos, length)来实现，也可以通过java.util.Arrays.copyOfRange(),如int[] b = Arrays.copyOfRange(a, 0, 3)；复制了0、1、2位置上的元素，复制的数组以方法的返回值返回，其中第二个参数作为数组的起始位置，能取到，第三个参数作为数组的结束位置，是取不到的。

二维数组：一维数组里面的每个元素是特定类型的值，而二维数组里的每个元素是一个一维数组，二维数组的初始化有以下几种方式：

```java
int [][] a = new int[2][3];//初始化了一个二维数组，里面有2个一维数组，一维数组长度为3
int [][] b = new int[2][];//只分配了二维数组，里面有2个一维数组，而每个一维数组的长度待定
b[0]  = new int[3]; //必须事先分配长度，才可以访问
b[0][2] = 5;
//分配空间的同时指定值
int[][] c = new int[][]{
               {1,2,4},
               {4,5},
               {6,7,8,9}
             };
或者 int[][] c = {
                {1,2,4},
                {4,5},
                {6,7,8,9}
              };
```

### 2、数组工具类Arrays

java.util.Arrays工具类提供了数组赋值（Arrays.copyOfRange，返回复制的数组）、转化为字符串（Arrays.toString，返回转化的字符串）、排序（Arrays.sort，无返回值）、搜索（Arrays.binarySearch，返回搜索值在数组中的索引位置）、判断是否相等（Arrays.equals，返回true或false）、填充值（Arrays.fill，无返回值）

## 五、对象

### 1、方法重载

方法的重载指的是方法名一样、但参数不一样。方法的多态值的是父类和子类的方法名相同。

### 2、构造方法

方法名和类名一样（包括大小写），没有返回类型，实例化一个对象的时候，必然调用构造方法。

### 3、this

this代表当前对象，在一个**构造函数**中，调用另一个构造方法，可以使用this()。

## 六、日期

### 1、日期类 Date

Date类（java.util.Date）

最特殊的数字：0，这个0就代表了Java中的时间原点，其对应的时间为1970年1月1日8点0分0秒（中国是太平洋时区UTC-8,格林威治时间差8小时），因为1969年发布了第一个Unix版本，所有的时间都是以这个0为基准，每过一毫秒就+1。

Date d = new Date(5000；表示1970年1月1日8:0:5，

getTime()方法返回一个long类型的整数，表示当前Date对象所表示的时间到1970年1月1日8:0:0之间的毫秒数。

System.currentTimeMillis()与getTime方法功能一样。

### 2、日期格式化类 SimpleDateFormat

SimpleDateFormat 日期格式化类

（1）、format()方法：日期转字符串

y代表年

M代表月

d代表日

H代表24小时制的小时

h代表12小时制的小时

m代表分钟

s代表秒

S代表毫秒

```java
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");
Date d = new Date();//当前时间
String str = sdf.format(d);
```

将当前时间通过格式yyyy-MM-dd HH:mm:ss SSS输出后：2020-06-24 15:49:23 288

（2）、parse()方法：字符串转日期

字符串的格式要和模式中的格式一致才能转换成功

```java
SimpleDateFormat sdf =new SimpleDateFormat("yyyy/MM/dd HH:mm:ss" );
String str = "2020/06/24 15:52:12";
Date date = sdf.parse(str);
```

将当前字符串形式的时间转化为Date：Wed  Jun  24  15:52:12  CST   2020

当只用年份来格式化创建日期时，创建的时间就是所给年份的1月1日00:00:00

### 3、日历类Calendar

Calendar 日历类，进行翻日历操作

add方法，在原日期上增加年/月/日
set方法，直接设置年/月/日

```java
Calendar c = Calendar.getInstance();//采用代理模型获取日历对象
Date d = c.getTime();//通过日历获取日期
```



