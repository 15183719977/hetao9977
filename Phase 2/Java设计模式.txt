                     模式：在某情境下，针对某问题的某种解决方案
2020-5-2 [模式总结]
1、装饰者：包装一个对象，以提供新的行为
2、状态：封装了基于状态的行为，并使用委托在行为之间切换
3、迭代器：在对象集合之中游走，而不暴露集合的实现
4、外观：简化一群类的接口
5、策略：封装可以互换的行为，并使用委托来决定要使用哪一个
6、代理：包装对象，以控制对此对象的访问
7、工厂方法：由子类决定要创建的具体类是哪一个
8、适配器：封装对象，并提供不同的接口
9、观察者：让对象能够在状态改变时被通知
10、模板方法：由子类决定如何实现一个算法中的步骤
11、组合：客户用一致的方式处理对象集合和单个对象
12、单例：确保有且只有一个对象被创建
13、抽象工厂：允许客户创建对象的家族，而无需指定他们的具体类
14、命令：封装请求成为对象（遥控器）
★何时应用模式：当系统未来可能改变时，多半需要设计模式来应对变化

――――――――――――――――――――――――――――――――――
★什么是设计模式：设计模式是过去人们面对同样软件设计问题所学来的经验
（设计模式是OO的圣经？）
★共23个设计模式
★每个设计模式的背后都包含了几个OO原则概念
-》OO原则是我们的目标，设计模式是具体的做法

▲设计原则 1
找出应用中可能需要变化的部分，将其独立出来，不要和不需要变化的代码混在一起
-》想一想鸭子的例子（继承可能会让某些子类拥有不恰当的行为；接口无法实现代码复用）
-》代码变化引起的不经意后果变少，系统更有弹性
-》★★所有的模式都提供了一套方法让“系统中的某部分改变不会影响其他部分”

▲设计原则 2
针对超类型（接口/抽象类）编程，而不是针对实现编程
-》以前是由子类实现父类的接口，现在将这部分（易改变的部分独立出来）放在接口中。
-》由行为类而不是Duck类来实现行为接口
★Duck类中需要定义类型为【接口】的实例变量，来引用具体【接口】实现类的对象（Quack以及FlyWithWings）
-》这个做法仍然有待改进，需要已经具备一定弹性（可在运行时改变）

▲设计原则 3
多用组合，少用继承
-》组合用在许多设计模式中，它拥有诸多优点和缺点
-》组合：将两个类结合起来使用（鸭子的行为不是继承来的，是和适当的行为对象组合来的）

*************************【设计模式-1】策略模式：
定义了算法族，分别封装起来，让它们之间可以相互替换，让变化独立于使用算法的客户

*************************【设计模式-2】观察者模式：
★★MVC框架是观察者模式的代表
★观察者模式是JDK中使用最多的模式之一
★观察者模式是：一对多的对象关系（一个主题对象对多个观察者对象）
★改变主题或者观察者其中一方，不会影响另一方，因为两者是松耦合的
▲设计原则 4
为了交互对象之间的松耦合设计而努力
★Java内置了观察者模式：java.util包内包含最基本的Observer【接口】（观察者）和Observable【类】（主题）
-》内置模式支持状态更新时，以两种不同方式通知观察者：推/拉
-》通知观察者以及观察者获取数据：
1、先调用setChanged()方法，标记状态已变更
2、调用notifyObservers()/notifyObservers(Object arg)
3、update(Observable o,Object arg)
                               ↑___数据对象，可为空：为空表示观察者自己去拉数据；不为空表示主题推数据
setChanged方法简单地将【内置的Observable类】的实例变量changed修改为true，仅当其为true时，notifyObservers
才会通知观察者【内置逻辑】
-》内置的Observable由于是一个类，限制了复用潜力（Java不支持多重继承），也违犯了设计原则：多用组合，少用继承

▲设计原则 5
类应该对扩展开放，对修改关闭（需求变更，不修改代码，但易扩展）
★遵循开放-关闭原则，通常会引入新的抽象层次，增加代码复杂度，不建议对系统所有部分都如此考虑

*************************【设计模式-3】装饰者模式：
定义-》动态地将责任附加到对象上，若要扩展功能，装饰者比继承更有弹性
★装饰者应该与被装饰者有相同的超类型（在任何需要原始对象的场合，都可以用装饰过的对象来代替）
★★装饰者可以在被装饰者的行为【之前】或【之后】，加上自己的行为，以达到特定目的
★★对象可以在任何时候被装饰

*************************【设计模式-4】工厂方法模式	《一句话：创建接口，具体实现放在子类中，用户代码使用该接口
定义-》将【对象创建】过程中可能出现的变化“封装”起来
★★工厂方法模式定义了一个创建对象的接口，由子类决定要实例化的类是哪个
（工厂方法让类把实例化【推迟】到子类）
★工厂模式通过让子类决定创建对象
★★工厂方法用来创建对象，需要被子类继承并被覆盖

▲设计原则 6（依赖倒置原则）
-》要依赖抽象，不要依赖具体类
★下面三个指导方针，将有助于在OO设计中违反依赖倒置原则（尽量遵循！而非一定遵循）：
1、变量不可以持有具体类的引用（引用工厂模式）
2、不要让类派生自具体类
3、不要覆盖基类中已实现的方法（这证明所设计的基类不是一个真正适合被继承的抽象）

*************************【设计模式-5】抽象工厂模式
定义-》提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类
★客户代码中只需要涉及抽象工厂，运行时将自动使用实际的工厂
★★抽象工厂里通常包含的是【工厂方法（设计模式-4）】

-》工厂方法和抽象工厂很容易混淆：
1、抽象工厂可以把一群相关的产品组合起来，是【对象的组合】
2、什么时候用抽象工厂？当需要创建产品家族以及让制造的相关产品集合起来时

*************************【设计模式-6】单例模式	      《只能创建唯一一个实例对象》
定义-》确保一个类只有一个实例，并提供一个全局访问点
★单例模式可以保证在需要时才创建对象，有且仅有一个对象
★在多线程的基础上使用单例模式要注意可能的风险：创建出不止一个单例对象
-》解决措施：
1、直接同步整个getInstance()方法
2、在单例对象声明时即进行初始化
3、双重检查加锁：在getInstance内部进行双重检查，在第二次检查时同步
-》注意双重检查加锁在<=1.4的Java版本中会导致错误（源于JVM对volatile关键字的实现）

★使用单例模式需要注意：
1、类的单例（所有方法和变量都声明为静态）有时也可行，但因为静态初始化的控制权在Java手上，这么做可能会导致
不容易发现的，与初始化次序有关的bug，因此不太建议
★如果程序有多个类加载器（每个类加载器都定义了一个命名空间），可能会产生多个单例
★BUG：在Java1.2以前，垃圾收集器会吃掉【没有全局引用】的单例，因此必须建立【单例注册表】

【待整合】
p294
★模板方法的抽象类中，可以带有一个默认不做事的方法，称为hook，子类可以视情况决定要不要覆盖它们
★子类必须覆盖模板方法中的步骤定义为abstract，可选的话，定义为hook
▲设计原则 X-好莱坞原则
让低层组件（子类）将自己挂钩到系统上，高层组件决定如何使用低层组件
（高层组件（抽象类中的模板方法）调用低层组件；低层组件不应该调用高层组件）
★低层组件也不是完全不能调用高层组件：
低层组件常常可能会调用从超类继承的方法，但重点在于避免让高层组件与低层组件之间有明显的【环状依赖】
★工厂方法模式是模板方法的一种特殊情况，由子类来决定要实例化的类是哪个
★★模板方法和策略模式有相似的地方：
策略模式通过在抽象类中定义【各行为的接口】（flyBehavior）以及一些直接调用这些接口的方法；子类则为接口提供具体的实现类，这样，通过对象组合（行为对象），就可以实现不同行为的组合


*************************【设计模式-9】迭代器模式与组合模式 《封装遍历
定义-》提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示
★Java提供的ListIterator接口支持向前遍历元素
★迭代器只意味着取出所有元素，并不假设元素之间的次序关系
▲设计原则 X+1-单一责任
一个类应该只有一个引起变化的原因
内聚（单一责任）的概念：当一个模块或类只支持一组【相关/不相关】的功能时，它具有高/低内聚
★当获得Hashtable/HashMap的迭代器时，应当获取的是其value对应的迭代器
★★Java 5新增了for/in的语句，甚至不需要显式创建迭代器

*************************【设计模式-10】组合模式 《像对待单个对象一样对待对象集合》
定义-》允许将对象组合成【树形】结构来表示“整体/部分”层次结构，组合能让客户以一致的方处理个别对象及对象组合
★使用组合结构，我们能将相同的操作应用于组合和个别对象上（可以忽略组合对象和个别对象之间的差别）
★★★尽管受到设计原则的指导，但有时，却会故意违反它，这是设计上的折衷
-》组合模式用【单一责任/安全性】设计原则换取【透明性】（客户不知道元素是组合还是叶节点），具体来说：
叶节点和组合（节点）包含一组相同的方法，客户可以直接调用其方法，而不管到底是叶节点还是组合，这就是透明性
另一方面，相同的某些方法可能对于叶节点/组合是没有意义的，为了安全性，也可以将该方法删除，此时客户对该方法调用之前
就必须判断该对象是组合还是叶节点，这就是损失了【透明性】，但增加了【安全性】

*************************【设计模式-11】状态模式：糖果机
定义-》允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类
（在不同的状态下，同一方法会实施不同的行为）
（使用组合通过引用不同的状态对象来造成类改变的假象）
★状态模式和策略模式的异同点：
1、状态模式：将一群行为封装在状态对象中，context的行为随时可以委托到状态对象中的任一个
2、策略模式：客户通常主动指定context所要组合的策略对象是哪一个，通常会有一个最合适的策略对象
-》策略模式可以想象成除了继承之外的一种弹性替代方案（如果继承了某个行为，则会被这个行为困住，很难修改）
-》状态模式可以想象成是在context中放置许多条件判断的替代方案
★策略模式通常会用行为或算法来配置Context类；状态模式允许Context随着状态改变而改变行为
★状态类可以被多个Context实例共享


*************************【设计模式-12】代理模式
定义-》为一个对象提供一个替身或者占位符以控制对该对象的访问
★控制访问：
1、远程代理控制访问远程对象
2、虚拟代理控制访问创建开销大的资源
3、保护代理基于权限控制对资源的访问
★为对象和其代理定义一个共同的接口，并让代理类持有对象的引用
★虚拟代理：直到真正需要一个对象时才创建它（延迟创建，等待创建完成）
★如何让客户使用代理而非真正的对象：在工厂方法内进行
★缓存代理会维护之前创建的对象

★★Java内置的动态代理：java.lang.reflect包
★组成：Proxy和RealSubject扩展自同一个接口，但Proxy由Java产生，我们需要对另一个类InvocationHandler进行设置，
该类控制Proxy类的行为，响应代理的调用
★proxy会将调用转发给InvocationHandler处理
★动态体现在：运行时才将proxy类创建出来
★Java 1.2的RMI不需要skeleton，利用reflectionAPI直接将客户调用分派给远程服务
★Java 5的RMI和动态代理搭配使用，连传统的stub也不需要了

*************************【设计模式-13】复合模式
★MVC是经典的复合模式
★MVC包含了组合模式、观察者模式、策略模式
-》MVC还常常用到适配器模式
★Web与MVC的结构也是非常相似的：
1、客户发出一个会被Servlet收到的HTTP请求（通常涉及表单数据）
2、Servlet扮演控制器，处理请求，向模型（数据库）发出请求，处理结果以JavaBean的形式打包（给视图）
3、控制器将控制权交给视图JSP，JSP生成页面，表现模型的视图（模型通过JavaBean中取得）
4、页面返回客户浏览器
【设计模型-额外】中介者模式：
定义-》封装对象之间的交互，不让两个对象之间相互显式引用，以达到松耦合的目的

*************【其他模式】-使用频率不如基本模式那么高
*************************【设计模式-桥接】
定义-》桥接模式通过将【实现】与【抽象】放在两个不同的类层次中而使它们可以独立地改变
★桥接模式适合使用在需要跨越多个平台的图形和窗口系统上
★当需要用不同的方式改变接口和实现时，桥接模式将非常适用


*************************【设计模式-生成器builder】
定义-》生成器模式封装一个产品的【构造过程】，并允许【按步骤】构造
★生成器模式允许对象通过多个步骤来创建，并且可以改变过程

*************************【设计模式-责任链】
定义-》为某个请求创建一个对象链，每个对象按顺序检查此请求，要么对其进行处理，要么转交给下一个对象
★用途：常用在窗口系统中，处理鼠标和键盘之类的事件

*************************【设计模式-Flyweight（蝇量/享元）模式】
-》让某个类的一个实例来提供许多“虚拟实例”
★减少运行时对象实例的个数，节省内存
★将许多“虚拟”对象的【状态（实例变量）】集中管理
★存在2个类：
1、管理类（用集合，如数组来管理所有虚拟实例的状态）
2、对象类（无状态）

*************************【设计模式-解释器模式】
定义-》解释器模式为语言创建解释器
★当需要实现一个简单的语言时，使用解释器模式

*************************【设计模式-中介者模式】
定义-》中介者模式来集中相关对象之间复杂的沟通和控制方式
★在没有中介者的情况下，所有对象都需要认识其他对象（对象之间需要交互）
★中介者内包含了整个系统的控制逻辑，简化了系统维护
★用途：中介者常被用来协调相关的GUI组件

*************************【设计模式-备忘录模式】
★备忘录存储系统关键对象的重要状态，同时也维护关键对象的封装
★单一责任原则：不要把保持状态的工作与关键对象混在一起：专门掌握状态的对象被称为备忘录

*************************【设计模式-原型Prototype】
定义-》当创建给定类的实例的过程很昂贵或很复杂时，使用原型模式
★原型模式允许通过复制现在的实例来创建新的实例（clone()方法，反序列化）
★原型模式的重点在于，客户代码在不知道要实例化何种特定类的情况下，可以制造出新的实例
★用途：在一个复杂的类层次中，当系统必须从其中的许多类型来创建对象时

*************************【设计模式-访问者】
定义-》当想要为一个对象的【组合】增加新的能力，且封装不重要时，使用访问者模式
★访问者必须获得组合内的每个元素，这个功能实现在导游对象中
★访问者通过导游的指引，收集组合中所有对象的状态，一旦收集完成，客户就可以让访问者对状态进行各种操作
（当需要新功能时，只要加强访问者即可）
