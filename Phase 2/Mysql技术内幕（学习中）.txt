<---------------------------注意事项：
-》Win下，Mysql 8的配置文件在：C:\ProgramData（隐藏）\MySQL\MySQL Server 8.0\my.ini
-》sakila数据库是MySQL提供的示例数据库
◎2020-6-2：聚簇索引是什么？和非聚簇索引（辅助索引）的区别？各自优缺点？
◎2020-6-2：每个表的space id有什么作用？是作为表的唯一标识符存在？
◎2020-6-2：辅助索引页又是什么？它和辅助索引有什么关系？（p50）

<---------------------------第一章 MySQL体系结构和存储引擎
★★★MySQL的核心就在于【存储引擎】
★MySQL数据库独有【插件式】存储引擎，这是区别于其他数据库的最重要特性
★MySQL 5.6版本是有史以来最大的一次更新，InnoDB存储引擎更是添加了许多功能
★区分核心概念：
【数据库】：文件或者其他形式文件类型的集合（如frm、MYD、MYI、ibd等结尾的文件）
【实例】：后台线程&共享内存区
-》数据库实例是操作数据库文件的
-》两者通常一一对应（集群情况下，一个数据库可被多个实例使用）
★Mysql、SQL server是【单进程多线程】数据库
-》Oracle是【多进程】数据库（但Win下也是单进程多线程）
-》MySQL数据库实例在系统上的表现是【一个进程】
mysqld进程就是MySQL实例？
★存储引擎是底层物理结构的实现，支持一系列标准的管理和服务
★存储引擎是基于【表】的，而不是数据库
★由于MySQL数据库是开源的，因此开发人员可以根据MySQL预定义的存储引擎接口编写自己的存储引擎
★InnoDB存储引擎最早是第三方存储引擎，后被Oracle收购

★★★存储引擎---------------------------
【InnoDB】
1、支持事务，设计目标主要面向【OLTP】（在线事务处理）的应用
2、特点：行锁设计、支持外键、支持非锁定读、支持全文索引
3、InnoDB存储引擎将数据放在一个逻辑的表空间中
（Mysql 4.1+ 可将每个InnoDB存储引擎的表单存放到一个独立的ibd文件中）
4、多版本并发控制MVCC
5、四种隔离级别
5、next-key locking策略避免幻读现象
6、提供了【插入缓冲】、【二次写】、【自适应哈希索引】、【预读】等功能
★对于表中的数据，InnoDB采用了【聚集（clustered）】的方式：表的存储按主键顺序进行存放
-》如果在表定义时没有指定主键，InnoDB会为每一行生成一个6字节的【ROWID】，并以此作为主键

【MyISAM】
1、不支持事件，表锁设计
2、支持【全文索引】，面向一些【OLAP】（在线分析处理）数据库应用
3、缓冲池只缓存索引文件，而不缓冲数据文件
4、MyISAM存储引擎由【MYD】（存放数据文件）和【MYI】（存放索引文件）组成
5、可使用myisampack工具来压缩数据文件（使用Huffman编码算法）

【NDB】：集群存储引擎
1、数据全部放于内存中-》主键查找的速度极快
2、缺陷：连接操作（JOIN）是在MySQL数据库层完成的，意味着复杂的连接操作需要巨大的网络开销

【Memory】（之前称HEAP存储引擎）
1、表中数据放于内存中，如果数据库重启或崩溃，则数据都将消失
-》适合存储临时数据，临时表，以及数据仓库中的【纬度表？】
2、使用哈希索引而不是B+数索引
3、只支持表锁，并发性能差，不支持TEXT和BLOB列类型
4、变长字段varchar实际上是按照定长字段char方式进行的，浪费内存
★5、MySQL数据库使用Memory存储引擎作为临时表来存放查询的中间结果集，若结果集大于Memory存储引擎表的容量设置，又或含有TEXT/BLOB类型字段，则被转换到MyISAM存储引擎表而存放到磁盘中

【Archive】：适合存储归档（压缩）数据，如日志信息
1、只支持INSERT和SELECT操作
2、压缩比可达10
3、提供行锁来实现高并发的插入操作

【Federated】
1、不存放数据，指向远程MySQL数据库服务器上的表
-》类似于SQL Server的链接服务器，Oracle的透明网关

【Maria】：取代MyISAM
1、支持缓存数据和索引文件
2、应用了行锁设计
3、提供MVCC
4、支持事务和非事务安全的选项
5、更好的BLOB字符类型的处理性能
★★★---------------------------

★连接方式：
1、TCP/IP
2、命名管道和共享内存（MySQL 4.1+）
3、UNIX域套接字：
mysql -uroot -S /tmp/mysql.sock


<---------------------------第二章 InnoDB存储引擎
★第一个完整支持A（原子性）C（一致性）I（隔离性）D（持久性）的存储引擎
★InnoDB体系架构：后台线程+内存池
-》后台线程：InnoDB是多线程模型，后台有多个不同的线程，负责不同的任务：
1、Master Thread：负责将缓冲池中的数据异步刷新到磁盘，保证数据一致性

2、IO Thread：InnoDB大量使用了AIO来处理【写】IO请求，极大提高数据库性能
IO Thread的工作就是负责这些IO请求的回调处理
-》可利用命令：show engine innodb status\G;来查看具体的IO Thread

3、Purge Thread：回收已经使用并分配的undo页
（早期版本中，回收功能在Master线程中）

4、Page Cleaner Thread：脏页的刷新

★InnoDB可被视为基于磁盘的数据库系统，其使用缓冲池技术来提高数据库的整体性能
★缓冲池中的页被写会到磁盘的时机是根据Checkpoint机制而定的（提高性能）
★缓冲池中缓存的数据页类型有：索引页、数据页、undo页、插入缓冲、自适应哈希索引、InnoDB存储的锁信息、数据字典信息等
★允许有多个缓冲池实例（每个页根据哈希值平均分配到不同缓冲池实例中）
★通常来说，数据库中的缓冲池是通过LRU算法来管理的
★在InnoDB中，缓冲池中的页大小默认是：16KB

★InnoDB对LRU算法进行了修改：新加入的页并非直接放入LRU列表的首部，而是在被称为midpoint的位置（LRU列表5/8处）；midpoint之前的列表称为new列表，之后的为old列表
-》原因在于：放入LRU首页的页仅仅可能是此次需要，而非真正的热点数据
★InnoDB引入参数innodb_old_blocks_time来设置页读取到mid位置后，需要等待多久被放入LRU的热端
★当页从LRU的old部分加入到new部分，此操作被称为page made young
？缓冲池中如何设置LRU列表的长度
★Free Buffers + Database Pages(LRU列表)可能不等于Buffer pool size，原因在于，缓冲池中的页还可能被分配给自适应哈希索引、Lock信息、Insert Buffer等页（这部分不需要LRU维护）
★缓冲池的命中率不应该低于95%（全表扫描可能会引起LRU列表的污染）
★InnoDB还可观察每个LRU列表中每个页的具体信息
？LRU列表有多个？不同的SPACE代表不同的LRU列表？
★InnoDB支持压缩页功能，原本16KB的页缩为1KB、2KB、4KB、8KB
-》由于页的大小发生了变化，对于非16KB的页，是通过unzip_LRU列表进行管理的
-》由于每个表的压缩比率可能不同，unzip_LRU对不同压缩页大小的页【分别】进行管理（伙伴算法）
★★在LRU列表中的页被修改后，被称为【脏页】：缓冲池中的页和磁盘上的页数据不一致
-》数据库会通过CHECKPOINT机制将脏页写回磁盘
-》【Flush列表】中的页即为脏页
-》脏页同时存在于Flush列表和LRU列表中
★由于脏页存在于LRU列表中，故可通过与查看LRU列表中的页同样的方法来查看脏页，但需要额外增加OLDEST_MODIFICATION > 0的SQL查询条件

★InnoDB存储引擎首先将重做日志信息放到redo log buffer、然后按一定的刷新频率将其写回重做日志文件
-》重做日志缓冲一般不需要设置得很大，因为每秒钟都会被写回
-》8MB的重做日志缓冲池总以满足绝大部分应用
★★重做日志缓冲被写回重做日志文件，仅当：
1、Master Thread每秒将重做日志缓冲写回重做日志文件
2、每个事务提交
3、重做日志缓冲池剩余空间小于1/2

★InnoDB对内存的管理是通过内存堆的方式进行的
-》在对一些数据结构（如缓冲池中的缓冲控制对象）【本身的内存】进行分配时，需要从【额外内存池】中进行申请
（InnoDB内存数据对象：缓冲池 + 重做日志缓冲 + 额外内存池）
-》因此，在申请了很大的InnoDB缓冲池时，也需要同时增加额外内存池的大小

★如果在脏页的写回过程中发生宕机，那么数据就不能恢复了！
-》为避免数据丢失，事务数据库普遍采用【Write:Ahead Log】策略：事务提交时，先写重做日志，再修改页，体现了ACID中的D的要求

★Checkpoint技术的目的是：
1、缩短数据库的恢复时间
2、缓冲池不够用时，将脏页写回磁盘
3、重做日志不够用时，写回脏页
-》当数据库宕机时，数据库不需要重做所有的日志，只需对checkpoint之后的重做日志进行恢复
★当缓冲池不够用时，LRU算法会淘汰出最近最少使用的页，若此页刚好为脏页，则强制执行checkpoint，写回脏页
★InnoDB是通过【LSN】（Log Sequence Number）来标记版本的：
1、每个页有LSN、重做日志有LSN、Checkpoint有LSN
★★在InnoDB中，有两种Checkpoint：
1、Sharp Checkpoint
-》发生在：数据库关闭时，将【所有】脏页都写回磁盘
2、Fuzzy Checkpoint
-》发生在：数据库运行时，只刷新一部分脏页
-》又分为：
【Master Thread Checkpoint】：以一定比例异步刷新，查询线程不会阻塞
【FLUSH_LRU_LIST Checkpoint】：发生在：被淘汰的LRU页是脏页时
【Async/Sync Flush Checkpoint】：发生在：重做日志不可用时，需要强制写回一部分脏页
-》重做日志不可用：由于重做日志是有限的，需要循环使用。
（当数据库宕机时，且重做日志还未被使用，此时必须强制产生Checkpoint）
定义：[checkpoint_age] = redo_lsn-checkpoint_lsn
async_water_mark = 0.75 * total_redo_log_file_size
sync_water_mark = 0.9 * total_redo_log_file_size
①[checkpoint_age] < async_water_mark：不需要写回脏页
②async_water_mark < [checkpoint_age] < sync_water_mark：触发异步刷新，从Flush列表中刷新足够的脏页回磁盘，直到不满足该条件
③[checkpoint_age] > sync_water_mark：很少出现该情况，除非重做日志设置得太小
★Async/Sync Flush Checkpoint是为了保证重做日志的循环使用的可用性
-》从MySQL 5.6+，刷新操作放入了单独的Page Cleaner Thread中，不会阻塞用户查询线程
【Dirty Page too much Checkpoint】：其可由参数innodb_max_dirty_pages_pct控制

■Master Thread工作方式 （InnoDB 【before 1.0.x版本】）：
内部由多个循环组成：主循环、后台循环、刷新循环、暂停循环
-》其根据数据库运行状态在不同循环中切换
【主循环】：包含大多数的操作，其中：
1、每秒钟的操作
①日志缓冲刷新到磁盘，即使事务未提交（总是执行）
②合并插入缓冲（根据当前IO负载决定是否执行）
③至多刷新100个InnoDB缓冲池中的脏页到磁盘（根据当前脏页比例决定是否执行）
④如果当前没有用户活动，切换至background loop
-》即使某个事务还未提交，InnoDB扔会每秒都将重做日志缓冲写到文件（这说明了为什么再大的事务提交的时间也是很短的）
2、每10秒钟的操作：
①刷新100个脏页到磁盘（根据近段时间内的IO负载决定是否执行）
②合并至多5个插入缓冲（总是执行）
③将日志缓冲刷新到磁盘（总是执行）
④删除无用的Undo页：【full purge】操作（总是执行）
⑤刷新100个或10个脏页到磁盘（总是执行）
-》注意：频率的控制是通过sleep来实现的，这意味着当负载很大的情况下，由于延迟而造成频率的不准确
★full purge：对表进行update、delete这类操作时，原先的行被标记为删除，但因为一致性读，需要保留这些行版本的信息。在该过程中，InnoDB会先判断已被标记为删除的行是否可以删除

【后台循环】：当数据库空闲或数据库关闭，执行操作：
①删除无用的Undo页（总是执行）
②合并20个插入缓冲（总是执行）
③跳回主循环（总是执行）
④不断刷新100个页直到符合某条件（跳转至flush loop中完成）
-》若flush loop也没有事情可做，则切换到suspend_loop，将Master Thread挂起，等待事件发生
-》在用户启用InnoDB存储引擎的条件下，但却没有使用任何基于InnoDB的表，则Master Thread总是处于挂起的状态

■Master Thread工作方式 （InnoDB 【1.0.x版本】）：
在上个版本中，InnoDB对IO是存在限制的，表现在缓冲池向磁盘刷新时做了一定的硬编码
（由于SSD的出现，这种硬编码会限制磁盘性能！）
★这种硬编码可能带来：
1、在写入密集的程序中，脏页和插入缓冲的速度可能对于MT的处理速度（100个脏页、20个插入缓冲），导致其“忙不过来”
2、宕机发生时，可能由于很多数据还没有写回磁盘，导致恢复时间需要很久
★改进：
对于刷新到磁盘页的数量，会根据新参数innodb_io_capacity进行控制（不再硬编码）
（几块磁盘做了RAID会提高IO性能）
-》用户可以根据磁盘IO吞吐量来设定该参数
★另一个问题是：innodb_max_dirty_pages_pct设定为90（%），显得太大了。
-》其默认值被修改为75
-》在之前的版本中，脏页比例若小于该值，不刷新脏页。现在即使小于该值，也会刷新脏页：
通过引入新参数innodb_adaptive_flushing：影响每秒刷新脏页的数量
（通过判断产生重做日志的【速度】来决定最合适的刷新脏页数量）
★InnoDB 1.0.x版本在性能方面取得了极大的提高
★可以根据主循环次数和挂起次数两个参数之间的差值来判断服务器的负载：
当主循环次数明显大于挂起次数时，说明服务器的压力较大

■Master Thread工作方式 （InnoDB 【1.2.x版本】）：
★刷新脏页的操作，从Master Thread线程分离到一个单独的Page Cleaner Thread


★★InnoDB关键特性：
1、插入缓冲Insert Buffer
2、两次写
3、自适应哈希索引
4、异步IO
5、刷新邻接页
【1、插入缓冲Insert Buffer】
★数据库表的索引从数据存储方式上可以分为聚簇索引和非聚簇索引（又叫二级索引）两种
-》“聚簇”的意思是数据行被按照一定顺序一个个紧密地排列在一起存储
★插入缓冲
-》InnoDB缓冲池中有Insert Buffer，但其也是物理页的组成部分？
★对主键插入操作，速度很快，但更多情况下，一张表上有多个非聚集的辅助索引secondary index
★InnoDB Insert Buffer缓存插入的【非聚集索引页】，然后以一定频率和情况进行Insert Buffer和辅助索引页子节点的合并操作（通常将多个插入合并到一个操作中）
★Insert Buffer的使用需要满足两个条件：辅助索引、索引不唯一
★存在的问题：写密集的情况下，插入缓冲会占用过多的缓冲池内存

★★InnoDB从1.0.x版本引入了【Change Buffer】，可对DML操作（Insert、Delete、Update）都进行缓冲；Change Buffer的适用对象仍然是非唯一的辅助索引
★Insert Buffer是一颗B+树（全局一颗，对所有表的辅助索引进行缓冲）：
非叶节点存放【查询的key】

★在InnoDB中，每个表有一个唯一的space id
★在辅助索引页插入到Insert Buffer B+树的情况下，为保证每次Merge Insert Buffer成功，还需要有一个特殊的【页】来标记每个辅助索引页的【可用空间】，该页的类型为：Insert Buffer Bitmap

★Insert Buffer中的【记录】何时合并到真正的辅助索引中：
1、辅助索引页被读取到缓冲池时（一次性合并所有该页在Insert Buffer上的缓冲记录）
2、Insert Buffer Bitmap发现辅助索引页的可用空间不够时，会强制进行合并操作：读取辅助索引页，将Insert Buffer中该页的记录及待插入的记录插入到辅助索引页中
3、Master Thread中进行的Merge Insert Buffer操作
-》这里执行Merge操作的不止是一个页，而是根据srv_innodb_io_capacity来决定要合并多少辅助索引页

【2、两次写】
Insert Buffer带给InnoDB性能上的提升，而两次写则保证了数据页的可靠性
★部分写失效：在InnoDB正在写入某个【页】到表中时，且此时宕机
★重做日志记录的是对页的物理【操作】，如果页本身已经损坏，则对其进行重做是没有意义的
-》这里的页是指什么？
解决方案：在应用重做日志前，需要一个页的副本
doublewrite由内存中的doublewrite buffer以及物理磁盘上【共享表空间】中的连续128个页组成
★在对缓冲池中的脏页进行刷新时，并不直接写磁盘，而是通过memcpy函数将脏页先复制到doublewrite buffer，之后再被顺序写入共享表空间的物理磁盘上，最后调用fsync函数，同步磁盘
-》共享表空间是什么？
-》数据文件是.ibd？
★如果需要较快的MySQL服务器性能，可以尝试禁用doublewrite功能，前提是用户有多个从服务器，来面对可能发生的写失效问题
（有些文件系统本身就提供了部分写失效的防范机制，如ZFS文件系统，此时可不用开启doublewrite）

【3、自适应哈希索引】
★哈希的查找时间复杂度为O(1)；而B+树的查询次数取决其高度，一般为3～4层，即3～4次查询
★自适应哈希索引：InnoDB会监控表上各索引页的查询，如果判断建立哈希索引可以带来速度提升，则建立哈希索引，AHI
★AHI通过缓冲池的B+页构造而来，因此建立的速度很快，不需要对整张表建立哈希索引
★InnoDB会自动根据访问的【频率】和【模式】来自动地为某些热点页建立哈希索引
★哈希索引只能用来搜索【等值】的查询

【4、异步IO，AIO】
★为提供磁盘操作性能，当前数据库系统都采用异步IO的方式来处理磁盘操作
★AIO的一个优势是可以将多个IO合并为1个IO，以提高IOPS
rrqm/s、wrqm/s：每秒的读、写请求被合并的个数
★从InnoDB 1.1.x开始，提供了内核级别的AIO支持，称为Native AIO（Win/Linux都支持）


【5、刷新邻接页】
★当刷新一个脏页时，InnoDB会检测该页所在区（extent）的所有页，如果有脏页，则一起刷新，其好处是可以通过AIO将多个IO合并
★该特性对机械硬盘的提升较大，固定硬盘则建议关闭

★命令START TRANSACTION开启事务可以防止MySQL自动提交？
★参数innodb_fast_shutdown控制数据库关闭时的innoDB操作：full purge和merge insert buffer
★参数innodb_force_recovery控制数据库启动时，对数据的恢复操作（上次非正常关闭，如宕机）


<---------------------------第三章    文件
★参数文件：通过mysql --help | grep my.cnf查找
★日志文件
★socket文件
★pid文件
★MySQL表结构文件
★存储引擎文件
【1、参数文件】：当MySQL启动时，数据库会先去读一个配置参数文件
->MySQL可以不需要参数文件，但必须要找到mysql架构（mysql数据库,use mysql;）
（mysql架构中记录了访问该实例的权限）
★参数可以通过show variables;命令查看
★MySQL没有所谓的隐藏参数，但Oracle、SQL Server存在
★参数又分为：动态参数、静态参数
1、动态参数：可通过set命令对动态参数进行修改
-》动态参数的作用域又分为【global】和【session】，表示修改是基于当前会话还是整个MySQL实例的生命周期
-》动态参数的修改并不会影响参数文件，因此下次启动MySQL时，还是应用参数文件中的值
2、静态参数（不允许动态修改）

【2、日志文件】
日志文件记录了影响MySQL数据库的各种类型活动，包括：
①错误日志.err：
-》通过命令：show variables like 'log_error'来定位该日志
-》错误日志不仅记录了所有错误信息，也记录了一些警告或正确的信息

②二进制日志：记录对MySQL数据库执行【更改】的所有操作，不包括select和show
-》作用：
1、恢复：某些数据的恢复需要二进制日志
2、复制：通过复制及执行二进制日志使slave和master进行实时同步
3、审计：通过二进制日志中的信息进行审计，判断是否有注入攻击
？什么叫审计
-》.index文件为二进制的索引文件，记录产生的二进制日志【序号】
-》默认文件名字：主机名.{二进制日志的序列号}，如YR97MCJ0FRZUBDI-bin.000001
-》参数max_binlog_size记录了单个二进制日志文件的最大值，超过该值，则产生新的二进制日志文件，序号+1
-》参数binlog_cache_size记录了未提交缓冲区的大小：
当使用基于事务的存储引擎时，所有未提交的二进制日志会被写入一个缓冲区，等事务提交时，直接将缓冲中内容写入二进制日志文件；当内容记录大小大于缓冲区大小后，又会被写入一个临时文件，因此该值不应该太小
-》binlog_format动态参数，表示日志记录格式可设置为：STATEMENT（SQL语句）、ROW（表的行更改情况，默认）
（ROW记录格式会为数据库的恢复和复制带来更好的可靠性，但会增加二进制文件的大小）
-》二进制日志是缓冲写，即会先写到缓冲区，再同步到磁盘
-》参数sync_binlog = [N] 表示每写缓冲 N 次就同步到磁盘（默认为1）
-》二进制日志的查看可通过mysqlbinlog（-vv）

③慢查询日志：帮助DBA定位可能需要优化的SQL语句（如执行速度太慢）
具体做法是：在MySQL启动时设定一个阈值long_query_time；运行时间超过该阈值的SQL语句将被记录到慢查询日志文件中
-》MySQL 8默认已经开启了慢日志查询，通过slow_query_log查看
-》通过命令：show variables like 'long_query_time'来定位该日志
-》还可将未使用索引的SQL语句加入慢查询日志
-》慢查询日志的呈现方式是：FILE（默认），可修改为：TABLE
（MySQL架构下的slow_log表）
-》InnoDB加强了SQL语句的捕获方式，增加了对【逻辑读取】和【物理读取】（磁盘IO）的统计：
将超过指定逻辑IO次数的SQL语句记录到日志中

④查询日志.log：
记录了所有对MySQL数据库的请求信息（无论是否正确执行），默认文件名为：主机名.log
（MySQL架构下的general_log表）

【3、套接字文件】
UNIX系统下本地连接MySQL采用套接字方式，需要一个套接字文件（socket）

【4、pid文件】
-》MySQL实例启动时，会将自己的进程ID写入该文件

【5、表结构定义文件】
★每个表都会有与之对应的文额件，不论采用何种存储引擎，都有一个以.frm为后缀的文件，记录表结构
★frm还用来记录视图的定义

【6、InnoDB存储引擎】
★★★MySQL 8 删除了frm文件，并采用 Serialized Dictionary Information (SDI)文件
（查看表结构信息，官方提供了一个工具叫做ibd2sdi，在安装目录下可以找到）
除了MySQL本身的文件（以上），还有与存储引擎相关的文件，包括：重做日志文件、表空间文件
①表空间文件：InnoDB采用【表空间】的形式存储数据，名为ibdata1
-》设置innodb_file_per_table后，用户可以为每个表产生一个独立表空间，命名规则：表名.ibd
（包含1个.frm文件和1个.ibd文件）
-》单独的表空间文件仅存储该表的数据、索引、插入缓冲BITMAP等信息、其余信息还是存放在默认的表空间中
②重做日志文件
ib_logfile0和ib_logfile1文件是InnoDB存储引擎的重做日志文件，记录了InnoDB的事务日志
★InnoDB至少有1个重做日志文件组（group），每组下至少拥有2个重做日志文件
★日志组中每个重做日志文件的大小一致，以循环写的方式运行：先写日志文件1，写满时，开始写日志文件2，写满又重新写日志文件1
★用户可开启镜像日志组，进一步提高可用性
（当磁盘本身已经做了高可用方案时，如磁盘阵列，则可不必开启该功能）
★重做日志文件的【大小】设置对InnoDB存储引擎的性能有着非常大的影响
（太大，恢复时间太久；太小，切换日志文件太频繁）
★重做日志有一个【capacity变量】，代表了最后的检查点不能超过该阈值，若超过，则必须将缓冲池中的部分脏页写回磁盘，导致用户线程阻塞
★★二进制日志与InnoDB重做日志的区别：
1、二进制记录所有的日志记录（包括其他存储引擎）
2、二进制日志的内容：关于事务的具体操作内容；InnoDB重做日志的内容：关于每个页的更改情况
3、提交时间不同：二进制日志仅在事务提交前进行提交，只写磁盘一次；但在事务进行过程中，不断有重做日志条目写入InnoDB重做日志文件中

★★重做日志的条目结构：
1、redo_log_type：重做日志的类型
2、space：表空间ID
3、page_no：页的偏移量
4、redo_log_body：恢复每个重做日志数据时，需要调用的函数

★★写入重做日志文件是缓冲写：重做日志缓冲往磁盘写入时，按512字节，即一个扇区大小进行写入，因为扇区是最小的写入单位，因此保证写入是必定成功的，因此不需要doublewrite（刷新脏页时使用）
★重做日志缓冲写入磁盘，仅当：
1、Master Thread每秒将重做日志缓冲写磁盘（不论事务的提交与否）
2、innodb_flush_log_at_trx_commit表示在提交时，处理重做日志的方式：
（=0：提交事务时，不将事务的重做日志写入磁盘上的日志文件；
  =1【默认】：执行commit时，重做日志缓冲同步写磁盘
  =2：执行commit时，重做日志缓冲异步写磁盘）


<---------------------------第四章    表
（表的物理存储特性）
【索引组织表】：表根据【主键】顺序组织存放
★没有显式指定主键时，InnoDB会：
1、找到第一个非空的唯一索引（NOT NULL、Unique）作为主键
-》如果有多个，按照定义索引（UNIQUE KEY(b)）的顺序选择第一个
2、如果没找到，则自动创建一个6字节大小的指针
-》_rowid可查看表的主键（仅限单个列为主键）
？多列组成的主键是什么？
★所有数据都被逻辑地存在【表空间】中：
-表空间由段segment组成
-段由区extent组成
-区由页page（又称块，block）组成

★常见的段有：数据段、索引段、回滚段等
-》数据段为B+树的叶子节点
-》索引段为B+树的非叶子节点
-》段的管理是存储引擎完成的，DBA不能也不需要管理
★★每个段开始时，先用32个页大小的碎片页来存放数据，使用完后才是64个连续页（以区的方式）的申请
（对于一些小表，开始时可以申请较少的空间，节省磁盘容量）

★区是由连续页组成的空间，每个区的大小为1MB，InnoDB存储引擎页的大小为16KB（默认），一个区中一共有64个连续的页（为保证连续型，InnoDB存储引擎一次从磁盘申请4-5个区）
-》InnoDB从1.0.x版本引入压缩页，每个页的大小可以通过参数KEY_BLOCK_SIZE设置为2K、4K、8K

★【页】是InnoDB磁盘管理的最小单位；默认为16KB，也可通过参数更改
★页的类型：
1、数据页（B+树的节点）
2、undo页
3、系统页
4、事务数据页
5、插入缓冲位图页
6、插入缓冲空闲列表页
7、未压缩的二进制大对象页
8、压缩的二进制大对象页

★数据库分为面向行（InnoDB）和面向列（当前发展方向）两种
-》页中保存着表中一行行的数据
★InnoDB存放行记录数据的格式：Compact、Redundant（兼容旧版本保留）
-》如果用户知道页中的行记录组织规则，也可编写工具自行读取

【Compact行记录格式】：MySQL 5.0中引入
-》一个页中存放的行数据越多，性能越高
★每行数据除了用户定义的列外，还有两个隐藏列：事务ID（6字节）、回滚指针列表（7字节，若没有定义主键，还有第三个隐藏列rowid（6字节））
-》【旧】Compact、Redundant格式称为Antelope文件格式
-》【新】Barracuda文件格式拥有：Compressed、Dynamic两种新的行记录格式
★Compressed不会在B-tree node存放前768字节的数据，只在数据页中存放20字节的指针，实际数据都放在Off Page中
-》Compressed行记录格式还提供了zlib压缩算法对行数据进行有效存储

★行溢出数据
InnoDB将一条记录中某些数据存储在数据页面之外，如BLOB、LOB，VARCHAR也有可能
-》VARCHAR(N)中的N指的是字符的【长度】；而VARCHAR最大支持的65535指的是【字节】
-》65535字节限制指的是：单个表中所有VARCHAR列的长度总和
★一般情况下，InnoDB的数据存放在B-tree node中，但发生行溢出时，数据存放在Uncompress BLOB页中，B-tree node也会存放数据（前768字节）：放不下的数据会放在BLOB页中；并存储偏移量指向溢出页
★多长的VARCHAR是保存在单个数据页中，从多长开始又会保存在BLOB中：
（适用于VARCHAR，以及TEXT、BLOB类型：因为TEXT、BLOB不总是放在Uncompressed BLOB Page中）
如果保证一个页能存放至少两条记录，那么数据就不会放在BLOB中

★在【多字节字符集】的情况下，CHAR和VARCHAR的实际行存储基本是没有区别的：
CHAR类型数据在不同的字符集编码下，可能有不同的字节长度，因此它也被看做是变长的












