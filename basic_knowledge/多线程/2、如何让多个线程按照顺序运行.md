# 2、如何让多个线程按照顺序运行

在上一篇文章中，我们学习了多线程的三种方式，但是我们发现一个问题：我是按照顺序启动的多个线程，为什么多个线程之间不是按照顺序运行的呢？这三个线程`abc`中，为什么运行顺序不是`aaaabbbbccc`也不是`abcabcabc`呢？现在我们来想一下，如果是`aaabbbccc`的方式，那么不就是顺序执行了吗？就没有达到多线程并行计算的效果了，那为什么也不是`abcabcabc`这种方式呢？那就要从线程的调度开始讲了。

### 线程的调度

在一个CPU运行多个线程的情况下，CPU会选择一定的调度算法来给每一个线程分配运行资源。同时，程序也能自己控制线程的状态。

##### 程序自发性切换

程序可以通过一下方式来进行线程之间的切换：

```
Thread.sleep()
Object.wait()
Thread.join()
Thread.yeild()
LockSupport.park()
```

##### 程序非自发性切换

* 线程的时间片用完

* 有一个更高优先级的线程需要被运行

* 虚拟机的垃圾回收

因此从上面我们可以知道，在上一篇文章中我们没有采用程序自发性的方式来控制线程的切换，因此程序是采用的非自发性的切换，然而非自发性的切换是一种我们无法控制且相对于我们来说是一个黑箱的过程，因此多个线程同时运行所输出的结果是一种没有规律的状态。那么我们应该怎么来控制线程让其可以按照顺序进行输出呢？

下面我将使用两个线程轮流输出奇偶数的方式来展示不同方法控制线程的执行顺序

### wait()、notify()

```java
package multi_process;

/**
 * @author: chenlei
 * @date: 12:05 2020/6/12
 **/
public class InTurnMultiProcess implements Runnable{
    static int value = 0;
    @Override
    public void run() {
        while (value < 100) {
            synchronized (InTurnMultiProcess.class){
                System.out.println(Thread.currentThread().getName() + ":" + value++);
                InTurnMultiProcess.class.notify();
                try {
                    InTurnMultiProcess.class.wait();
                }catch (InterruptedException e){
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        new Thread(new InTurnMultiProcess(),"偶数线程").start();
        new Thread(new InTurnMultiProcess(),"奇数线程").start();
    }
}
```

输出结果：

```
偶数线程:0
奇数线程:1
偶数线程:2
奇数线程:3
偶数线程:4
奇数线程:5
偶数线程:6
奇数线程:7
偶数线程:8
奇数线程:9
偶数线程:10
```

通过上面的输出结果可以看到，奇数线程和偶数线程一次进行了输出。下面解读一下本代码，在这段代码中，主要的是`run`函数中的`while`循环的代码比较重要。在`while`的循环中使用了一个关键字`synchronized`，该关键字的作用是保证代码的访问的互斥性，也就是一个时刻只能有一个线程访问该代码段，因此一定是一个线程执行完本段代码之后另一个线程才能访问本段代码，相当于给这段代码上了锁，一段时间内只能有一个线程拥有该锁。然后比较重要的就是`notify()`方法和`wait()`方法，这两个方法是`Object`的`final`方法，无法被重写。其中`notify()`方法的作用是唤醒其他线程，但是并不会释放本线程所持有的锁，而wait方法就是释放当前的锁，让出CPU，进入等待状态。

`notify()`和`wait()`这样的方法能够让一个线程知道另一个的状态等信息，因此是线程之间进行了通信，然而，线程之间通信的方式可不止这一种，后面，我们再继续学习多线程通信的问题。