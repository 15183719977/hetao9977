# 1、多线程的三种实现方式

## 线程与进程

线程是一个具有一定独立功能的程序在一个数据集上的一次动态执行过程，是**操作系统进行资源分配和调度的基本单位** ，是应用程序的载体，由程序、数据集合和进程控制三部分组成。其具有动态性、并发性、独立性和结构性四种特点。

线程是**程序执行的最小单位**，一个进程中可以有多个线程，线程之间共享内存空间（代码段、数据集、堆等）。

## 多线程

`Java`中多线程创建有三种方式：继承`Thread`类、实现`Runnable`接口和继承类三种。

### 1. 继承Thread类

##### 实体类

实体类是一个我们实现功能的类，在这个类里面我定义其输出名字和自己的`total`并进行自增操作。

```java
package multi_process;

import lombok.Data;

import java.util.Random;

/**
 * @author: chenlei
 * @date: 14:28 2020/6/11
 **/
@Data
public class Man{
    private String name;
    private Integer total;
    public Man(String name,Integer total) {
        this.name = name;
        this.total = total;
    }

    public void play() {
        this.total ++;
        System.out.println(name + ":" + total);
    }
}

```

##### 多线程类

该类通过继承Thread类的方式来实现多线程。在这里面我们控制如果`total`没有到20那么就继续运行。

```java
package multi_process;

/**
 * @author: chenlei
 * @date: 14:44 2020/6/11
 **/
public class PlayThread extends Thread {
    Man man;
    public PlayThread(Man man) {
        this.man = man;
    }
    public void run() {
        while (man.getTotal() < 20) {
            man.play();
        }
    }
}
```

##### 主类

主类主要包含的是Main函数，通过该函数启动多个线程，并将其启动让其运行

```
package multi_process;

/**
 * @author: chenlei
 * @date: 14:27 2020/6/11
 **/
public class Main {
    public static void main(String[] args) {
        Man blue = new Man("blue",0);
        Man red = new Man("red",0);

        PlayThread blueThread = new PlayThread(blue);
        PlayThread redThread = new PlayThread(red);
        blueThread.start();
        redThread.start();
    }

}
```

##### 结果

```text
red:1
blue:1
green:1
blue:2
red:2
blue:3
green:2
blue:4
red:3
blue:5
green:3
blue:6
```

从上面的部分输出结果我们可以看到，三个线程均进行了自增操作，但是他们却没有按照我们的启动顺序按照顺序执行。

### 2.实现接口

##### 实体类

该类不做改变

##### 多线程类

该类的逻辑功能不做改变，只是将继承类改为了实现接口。

```java
package multi_process;

/**
 * @author: chenlei
 * @date: 15:33 2020/6/11
 **/
public class PlayThread1 implements Runnable {
    Man man;
    public PlayThread1(Man man) {
        this.man = man;
    }
    public void run() {
        while (man.getTotal() < 20) {
            man.play();
        }
    }
}
```

##### 主类

```java
package multi_process;

/**
 * @author: chenlei
 * @date: 14:27 2020/6/11
 **/
public class Main {
    public static void main(String[] args) {
        Man blue = new Man("blue",0);
        Man red = new Man("red",0);
        Man green = new Man("green",0);
        PlayThread1 blueThread = new PlayThread1(blue);
        PlayThread1 redThread = new PlayThread1(red);
        PlayThread1 greenThread = new PlayThread1(green);
        new Thread(blueThread).start();
        new Thread(redThread).start();
        new Thread(greenThread).start();
    }

}
```

##### 输出结果

```
red:1
green:1
blue:1
green:2
red:2
green:3
blue:2
blue:3
blue:4
blue:5
blue:6
```

这次的输出结果能看出来每一个都在进行自增操作，但是顺序比上面的更加离谱，这是因为换了方法吗？请继续阅读下去。

### 3. 匿名类

该方法可以不用新建一个类文件，只需要在主类中使用`new`的方式来新增一个对象并实现该对象的`run`方法就可以。因此该方法就将多线程类和主类合并，代码如下：

```java
package multi_process;

/**
 * @author: chenlei
 * @date: 14:27 2020/6/11
 **/
public class Main {
    public static void main(String[] args) {
        Man blue = new Man("blue",0);
        Man red = new Man("red",0);
        Man green = new Man("green",0);
        //匿名内部类
        Thread blueThread = new Thread(){
            public void run() {
                while (blue.getTotal() < 20) {
                    blue.play();
                }
            }
        };
        Thread redThread = new Thread(){
            public void run() {
                while (red.getTotal() < 20) {
                    red.play();
                }
            }
        };
        Thread greenThread = new Thread(){
            public void run() {
                while (green.getTotal() < 20) {
                    green.play();
                }
            }
        };
        blueThread.start();
        redThread.start();
        greenThread.start();
    }

}
```

##### 输出结果

```
green:1
blue:1
blue:2
blue:3
blue:4
blue:5
blue:6
blue:7
blue:8
blue:9
blue:10
blue:11
blue:12
```

上面的输出结果仍然无序自增，有的小伙伴可能更加疑惑了，这到底是为什么呢？其实这是因为线程切换是随机的，因此这三个线程输出没有顺序。那我们要怎样才能让他们按照顺序输出呢？那就要聊到加锁了，请见下一篇文章。