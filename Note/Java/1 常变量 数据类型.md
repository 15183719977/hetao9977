# 常变量 数据类型

## 常量

- 使用关键字 **final** 进行初始化：`final int a = 1;`

## 变量

### 初始化

- 全局变量中，静态/非静态成员变量有默认值
- **局部变量只有非静态变量，且必须赋值**

| 数据类型 |  默认值  |    数据类型     |  默认值  |
| :------: | :------: | :-------------: | :------: |
|   byte   |    0     |   static byte   |    0     |
|  short   |    0     |  static short   |    0     |
|   char   | '\u0000' |   static char   | '\u0000' |
|   int    |    0     |   static int    |    0     |
|   long   |    0L    |   static long   |    0L    |
|  float   |   0.0F   |  static float   |   0.0F   |
|  double  |   0.0    |  static double  |   0.0    |
| boolean  |  false   | static boolean  |  false   |
|  String  |   null   |  static String  |   null   |
| String[] |   null   | static String[] |   null   |



## 数据类型

### 基本数据类型

#### 整数类型

| 数据类型 | 关键字 |   内存占用    |                取值范围                |
| :------: | :----: | :-----------: | :------------------------------------: |
|  字节型  |  byte  | 1byte / 8bit  |         -2^7~2^7-1 (-128~127)          |
|  短整型  | short  | 2byte / 16bit |      -2^15~2^15-1  (-32768~32767)      |
|   整形   |  int   | 4byte / 32bit | -2^31~2^31-1  (-2147483648~2147483647) |
|  长整形  |  long  | 8byte / 64bit |              -2^63~2^63-1              |

- 计算时，byte, short, char 类型的变量自动转型为 int
  - 常量需要强制转换
- Java的跨平台性，内存占用与平台无关
- **长整形需要后缀**：`long ac=16l` / `long ad=16L`

#### 浮点类型

|   数据类型   | 关键字 |   内存占用    | 取值范围 |
| :----------: | :----: | :-----------: | :------: |
| 单精度浮点数 | float  | 4byte / 32bit |    -     |
| 双精度浮点数 | double | 8byte / 64bit |    -     |

- 小数的默认类型是 **double**
- **单精度浮点型需要后缀：**`float ab=0.12f` / `float ac=0.12F`

#### 字符类型

| 数据类型 | 关键字 |   内存占用    | 取值范围 |
| :------: | :----: | :-----------: | :------: |
|  字符型  |  char  | 2byte / 16bit | 0-65536  |

- 区别 字符 与 字符串
  - 字符 char：单引号，有且只有一个字符 
  - 字符串 string：双引号，不限字符
- 字符编码：Java采用Unicode编码
  - 中文：1 字符=3 字节
  - 英文：1 字符=1 字节
  - 对比 GBK 编码，中英文：1 字符=2 字节

#### 布尔类型

| 数据类型 | 关键字 |   内存占用    | 取值范围 |
| :------: | :----: | :-----------: | :------: |
| 布尔型 | boolean | 1byte / 8bit | true / false |

- **不能用 0/1 代替 false/true**

#### 类型转换

- 自动类型转换/隐式转换
  - 方向不看字节数，看范围
  	- ```mermaid
  graph LR
  A[byte] -->B[short]
	  B --> C[int]
      C --> D[long]
      D --> F[float]
      F --> G[double]
      A2[char] --> C
      ```
	  
	- a = b + c
  	
  	- b, c 作为变量时，计算会自动转型；作为常量时，不会自动转型；
  		
  		- b, c 作为常量，为 byte, short, char, int 时，左边可以为 byte, short, char, int, long, float, double 任意类型
  		- b, c 作为常量，为 long, float, double 时，左边只能为同级或更高级
  		
  	- ```java
  	  final short b1 = 1;
  	  final short b2 = 2;
  	  
  	  short c1 = 1;
  	  short c2 = 2;
  	  
  	  byte a1 = b1 + b2;
  	  byte a2 = c1 + c2;	// 报错，变量会自动转型为 int
  	  
  	  short a3 = b1 + b2;
  	  short a4 = c1 + c2;	// 报错，变量会自动转型为 int
  	  
  	  int a5 = b1 + b2;
  	  int a6 = c1 + c2;
  	  ```
- 强制类型转换/显示转换
- 精度问题
  - 转换对象问题
      - (short)10/2.2+1：转换的是10
      - (short)(10/2.2+1)

#### 数字表示

- 进制表示
  - 二进制：0b 为前缀
  - 八进制：0 为前缀
  - 十进制：无前缀
  - 十六进制：0x为前缀

### 引用数据类型

- 类似CPP中的指针类型
- 分类：数组、接口、类、Lambda

### 方法中参数传递问题

- Java 在方法中 **按值传递**，没有按引用传递
  - 按引用传递的本质是拷贝指向对象的堆内存地址
- 基本数据类型
  - 在方法中没有修改参数变量，参数变量**保持原变量的值和内存地址**
  - 在方法中修改参数变量，参数变量的值和内存地址改变，**不影响原变量的值和内存地址**
- 引用数据类型
  - 在方法中没有修改参数引用，参数引用**保持原始引用的值和栈内存地址 **
    - 引用的值是 **指向的对象的堆内存地址**
    - ![ae8a649f33c22dd963aa3083a52429da.png](https://martinvon-img.oss-cn-beijing.aliyuncs.com/Image.png)
  - 在方法中修改参数引用
    - 修改参数引用的值，参数引用的值和栈内存地址改变，不影响原始引用的值和栈内存地址，**不影响原始引用指向的对象的值**
    - 修改参数引用指向的对象的值，参数引用的值和栈内存地址不变，不影响原始引用的值和栈内存地址，**影响原始引用指向的对象的值**


```

```