**多线程（并发机制）：**

程序、进程、线程：

**程序**：“程序(Program)”是一个静态的概念，一般对应于操作系统中的一个可执行文件，当我们双击可执行文件，则加载程序到内存中，开始执行该程序，于是产生了“进程”。

**进程**：执行中的程序（包含自身地址的程序）叫做进程(Process)，是一个动态的概念。

 1. 进程是程序的一次动态执行过程， 占用特定的地址空间。

      2.
每个进程由3部分组成：cpu、data、code。每个进程都是独立的，并有自己的cpu时间（一段有限的极短的CPU时间，CPU时间片），数据和代码，即便用同一份程序产生好几个进程，它们之间还是拥有自己的这3样东西，这样的缺点是：浪费内存，cpu的负担较重。

      3.
多任务(Multitasking)操作系统将CPU时间动态地划分给每个进程，操作系统同时执行多个进程，每个进程独立运行。以进程的观点来看，它会以为自己独占CPU的使用权。

      4. 进程的查看

          Windows系统: Ctrl+Alt+Del，启动任务管理器即可查看所有进程。

          Unix系统: ps or top。

**线程：**一个进程可以产生多个线程。同多个进程可以共享操作系统的某些资源一样，同一进程的多个线程也可以共享此进程的某些资源(比如：代码、数据)（极极短的时间），所以线程又被称为轻量级进程(lightweight
process)。

      1.
一个进程内部的一个执行单元，它是程序中的一个单一的顺序控制流程。（一个线程是进程中的执行流程）

      2. 一个进程可拥有多个并行的(concurrent)线程。

      3.
一个进程中的多个线程共享相同的内存单元/内存地址空间（存储空间），可以访问相同的变量和对象，而且它们从同一堆中分配对象并进行通信、数据交换和同步操作。

      4.
由于线程间的通信是在同一地址空间上进行的，所以不需要额外的通信机制，这就使得通信更简便而且信息传递的速度也更快。

      5. 线程的启动、中断、消亡，消耗的资源非常少。

**程序和进程的区别：**程序是一组指令的集合，它是静态的实体，没有执行的含义。而进程是一个动态的实体，有自己的生命周期。一般说来，一个进程肯定与一个程序相对应，并且只有一个，但是一个程序可以有多个进程，或者一个进程都没有。除此之外，进程还有并发性和交往性。简单地说，进程是程序的一部分，程序运行的时候会产生进程。

**线程和进程的区别：**

![IMG_256](media/a2c1b822ed1c0f000c636edacdb6e0f9.png)

![1553074451(1)](media/4227c7cb354c2db84f2707e3d3e9971b.png)

1.  定义多线程类的两种方式（一个接口一个类）：

    1.  extends Thread（实际上这个类也是实现了接口public class Thread extends
        Object implements Runnable）

**public** **class** TestThread **extends** Thread {//自定义类继承Thread类

    //run()方法里是线程体

    **public** **void** run() {

        **for** (**int** i = 0; i \< 10; i++) {

            System.out.println(**this**.getName() + ":" + i);//getName()方法是返回线程名称

        }

    }

 

    **public** **static** **void** main(String[] args) {

        TestThread thread1 = **new** TestThread();//创建线程对象

        thread1.start();//启动线程

        TestThread thread2 = **new** TestThread();

        thread2.start();

    }

}

    继承Thread类实现多线程的步骤：

**class** MyThread **extends** Thread{

}

MyThread t1=new MyThread( "t1" );

 Thread t1 = **new** Thread(**new** MyThread(), "t1");

      1. 在Java中负责实现线程功能的类是java.lang.Thread 类。

      2. 可以通过创建 Thread的实例来创建新的线程。在main中new

      3. 每个线程都是通过某个特定的Thread对象所对应的方法run(
)（覆盖）来完成其操作的，方法run(
)称为线程体（真正实现该线程功能的代码）。run()不产生线程。

      4.
通过调用Thread类的start()方法来启动一个线程。(在start()前是实例，后是线程)

>   main(){

>   new ThreadTest().start();

>   }

1.  Implements Runnalbe(在实现Runnable接口的同时还可以继承某个类)

>   **public** **class**  MyThread **implements** Runnable{

>   }

>   MyThread t1=new MyThread( "t1" );

>   Thread t1 = **new** Thread(**new**  MyThread(),"t1");

Runnable r = **new** MyThread();

        Thread t = **new** Thread(r, "t1")

**public** **class** TestThread2 **implements** Runnable {//自定义类实现Runnable接口；

    //run()方法里是线程体；

    **public** **void** run() {

        **for** (**int** i = 0; i \< 10; i++) {

            System.out.println(Thread.currentThread().getName() + ":" + i);

        }

    }

    **public** **static** **void** main(String[] args) {

        //创建线程对象，把实现了Runnable接口的对象作为参数传入；

        Thread thread1 = **new** Thread(**new** TestThread2());

        thread1.start();//启动线程；

        Thread thread2 = **new** Thread(**new** TestThread2());

        thread2.start();

    }

}

>   c)

![](media/df995b1205851cdfc6a806f7331d6319.png)

>   1553156474(1)

>   d)

![](media/7307dbeccf4296151ed007a57a2ac608.png)

>   1553156496(1)

1.  线程的状态：

![IMG_256](media/7e336dda90eb50c23eaf76fa29b5bf3e.png)

1.  新生状态(New)：用new关键字建立一个线程对象后，该线程对象就处于新生状态。处于新生状态的线程有自己的内存空间，通过调用start方法进入就绪状态。

2.  就绪状态(Runnable)(调用start方法后)：处于就绪状态的线程已经具备了运行条件，但是还没有被分配到CPU，处于“线程就绪队列”，等待系统为其分配CPU。就绪状态并不是执行状态，当系统选定一个等待执行的Thread对象（线程）后，它就会进入执行状态。（该动作称之为“CPU调度”）

>   一旦获得CPU，线程就进入运行状态并自动调用自己的run方法。有4中原因会导致线程进入就绪状态：

>   1. 新建线程：调用start()方法，进入就绪状态;

>         2. 阻塞线程：阻塞解除，进入就绪状态;

>         3.
>   运行线程：调用yield（让位）()方法，交出控制权，直接进入就绪状态;没其他等待执行的线程，马上恢复执行

>         4. 运行线程：JVM将CPU资源从本线程切换到其他线程。

1.  运行状态(Running)（由CPU调度好以后）:   在运行状态的线程执行自己run方法中的代码，直到等待某资源而阻塞(调用其他方法而终止)或完成任务而死亡。如果在给定的时间片内没有执行结束，就会被系统给换下来回到就绪状态。

2.  阻塞状态(Blocked):
    阻塞指的是暂停一个线程的执行以等待某个条件发生(如某资源就绪)。

>   有4种原因会导致阻塞：

>     1. 执行sleep(int
>   millsecond)方法，使当前线程休眠，进入阻塞状态。当指定的时间到了后，线程进入就绪状态。不会释放持有的对象锁
>   没其他等待执行的线程，马上恢复执行

>      2.
>   执行wait()方法，使当前线程进入阻塞状态。当使用nofity（通知）()方法唤醒这个线程后，它进入就绪状态。会释放持有的对象锁

>          3.
>   线程运行时，某个操作进入阻塞状态，比如执行IO流操作(read()/write()方法本身就是阻塞的方法)。只有当引起该操作阻塞的原因消失后，线程进入就绪状态。（在阻塞状态的线程不能进入就绪队列。只有当引起阻塞的原因消除时，线程便转入就绪状态，重新到就绪队列中排队等待，被系统选中后从原来停止的位置开始继续运行）

>          4. join()线程联合:
>   当某个线程等待另一个线程执行结束后，才能继续执行时，使用join()方法。

>   5.synchronized：运行同步代码，但是没有获得指定对象的锁，于是进入指定对象的锁池（lock
>   pool）等待。

1.  死亡状态(Terminated)：死亡状态是线程生命周期中的最后一个阶段。线程死亡的原因有三个。一个是正常运行的线程完成了它run()方法内的全部工作;
    另一个是线程被强制终止，如通过执行stop()或destroy()方法来终止一个线程(注：stop()/destroy()方法已经被JDK废弃，不推荐使用)。 当一个线程进入死亡状态以后，就不能再回到其它状态了。三是线程抛出未捕获的异常。

    1.  不建议使用：stop、destroy直接终止。（不会释放锁，会有一些安全的问题）

    2.  建议通过boolean变量，正常终止线程运行。

**public** **class** TestThreadCiycle **implements** Runnable {

    String name;

    **boolean** live = **true**;// 标记变量，表示线程是否可中止；

    **public** TestThreadCiycle(String name) {

        **super**();

        **this**.name = name;

    }

    **public** **void** run() {

        **int** i = 0;

        //当live的值是true时，继续线程体；false则结束循环，继而终止线程体；

        **while** (live) {

            System.out.println(name + (i++));

        }

    }

    **public** **void** terminate() {

        live = **false**;

    }

 

    **public** **static** **void** main(String[] args) {

        TestThreadCiycle ttc = **new** TestThreadCiycle("线程A:");

        Thread t1 = **new** Thread(ttc);// 新生状态

        t1.start();// 就绪状态

        **for** (**int** i = 0; i \< 100; i++) {

            System.out.println("主线程" + i);

        }

        ttc.terminate();

        System.out.println("ttc stop!");

    }

}

![IMG_256](media/aa578626c7fef6c85ae6257447029f9f.png)

1.  线程的优先级Thread.MIN/MAX/NORMAL_PRIORITY=1/10/5

    1.  1-10. 默认是5.（ int getPriority(); void setPriority(int newPriority);）

优先级低只是意味着调用的概率低，并不是不被调用。（注意：优先级低只是意味着获得调度的概率低。并不是绝对先调用优先级高的线程后调用优先级低的线程）

1.  资源(线程)同步：线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个对象的等待池形成队列，等待前面的线程使用完毕后，下一个线程再使用。

>   synchronized修饰方法：控制对“对象的类成员变量”的访问：每个对象对应一把锁，每个
>   synchronized
>   方法都必须获得调用该方法的对象的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。（需要获得执行该方法的对象锁）、

>   **public**  **synchronized**  **void** accessVal(**int** newVal);

>   缺陷：若将一个大的方法声明为synchronized 将会大大影响效率。

>   synchronized修饰语句块： 可以让我们精确地控制到具体的“成员变量”，缩小同步的范围，提高效率。（指定（后面跟着的对象）的锁、建议使用）

**synchronized**(syncObject)

　  { 

　　 //允许访问控制的代码 //同步监视器

}

**class** Drawing **extends** Thread {

    **int** drawingNum; // 取多少钱

    Account account; // 要取钱的账户

    **int** expenseTotal; // 总共取的钱数

 

    **public** Drawing(**int** drawingNum, Account account) {

        **super**();

        **this**.drawingNum = drawingNum;

        **this**.account = account;

    }

 

    \@Override

    **public** **void** run() {

        draw();

    }

 

    **void** draw() {

        **synchronized** (account) {

            **if** (account.money - drawingNum \< 0) {

                System.out.println(**this**.getName() + "取款，余额不足！");

                **return**;

            }

            **try** {

                Thread.sleep(1000); // 判断完后阻塞。其他线程开始运行。

            } **catch** (InterruptedException e) {

                e.printStackTrace();

            }

            account.money -= drawingNum;

            expenseTotal += drawingNum;

        }

        System.out.println(**this**.getName() + "--账户余额：" + account.money);

        System.out.println(**this**.getName() + "--总共取了：" + expenseTotal);

    }

}

![](media/b2261cc92db8b2e5fea7f2585bb6450b.png)

>   1553156995(1)

![](media/3402469826f76236ad2d017ce12e1db7.png)

>   1553157040

![](media/25f8971c2b1ca99240a50b1e397818ad.png)

>   1553156914(1)

1.  死锁（需要同时持有两个对象的锁）: 多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能进行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。

      因此，
某一个同步块需要同时拥有“两个以上对象的锁”时，就可能会发生“死锁”的问题

>   建议不要同时持有多个对象的锁！

1.  多线程并发协作模型:“生产者-消费者”模式（解决资源冲突的问题）:

2.   生产者：指的是负责生产数据的模块(这里模块可能是：方法、对象、线程、进程)。

3.  消费者：指的是负责处理数据的模块(这里模块可能是：方法、对象、线程、进程)。

4.  缓存区：消费者不能直接使用生产者的数据，它们之间有个“缓冲区”。生产者将生产好的数据放入“缓冲区”，消费者从“缓冲区”拿要处理的数据。

>    缓冲区是实现并发的核心，缓冲区的设置有3个好处：

1.  实现线程的并发协作

2.  解耦了生产者和消费者

3.  解决忙闲不均，提高效率

>   开源框架quanz底层原理

>   任务定时调度：

>   通过Timer和Timetask，我们可以实现定时启动某个线程。

>   java.util.Timer

>      
>     在这种实现方式中，Timer类作用是类似闹钟的功能，也就是定时或者每隔一定时间触发一次线程。其实，Timer类本身实现的就是一个线程，只是这个线程是用来实现调用其它线程的。

>   java.util.TimerTask

>      
>     TimerTask类是一个抽象类，该类实现了Runnable接口，所以该类具备多线程的能力。

>   在这种实现方式中，通过继承TimerTask使该类获得多线程的能力，将需要多线程执行的代码书写在run方法内部，然后通过Timer类启动线程的执行。

**public** **class** TestTimer {

    **public** **static** **void** main(String[] args) {

        Timer t1 = **new** Timer();//定义计时器；

        MyTask task1 = **new** MyTask();//定义任务；

        t1.schedule(task1,3000);  //3秒后执行；

        //t1.schedule(task1,5000,1000);//5秒以后每隔1秒执行一次！

        //GregorianCalendar calendar1 = new GregorianCalendar(2010,0,5,14,36,57); 

        //t1.schedule(task1,calendar1.getTime()); //指定时间定时执行； 

    }

}

 

**class** MyTask **extends** TimerTask {//自定义线程类继承TimerTask类；

    **public** **void** run() {

        **for**(**int** i=0;i\<10;i++){

            System.out.println("任务1:"+i);

        }

    }

}

>   一个Timer可以启动任意多个TimerTask实现的线程，但是多个线程之间会存在阻塞。所以如果多个线程之间需要完全独立的话，最好还是一个Timer启动一个TimerTask实现。
